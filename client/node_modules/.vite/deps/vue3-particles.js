import {
  createElementBlock,
  defineComponent,
  nextTick,
  openBlock
} from "./chunk-ZV5R4Z6I.js";
import "./chunk-CWJMTW5E.js";

// node_modules/vue3-particles/dist/vue3-particles.es.js
var We = class {
  constructor() {
    this._listeners = /* @__PURE__ */ new Map();
  }
  addEventListener(e, t) {
    this.removeEventListener(e, t);
    let i = this._listeners.get(e);
    i || (i = [], this._listeners.set(e, i)), i.push(t);
  }
  dispatchEvent(e, t) {
    const i = this._listeners.get(e);
    i && i.forEach((s) => s(t));
  }
  hasEventListener(e) {
    return !!this._listeners.get(e);
  }
  removeAllEventListeners(e) {
    e ? this._listeners.delete(e) : this._listeners = /* @__PURE__ */ new Map();
  }
  removeEventListener(e, t) {
    const i = this._listeners.get(e);
    if (!i)
      return;
    const s = i.length, o = i.indexOf(t);
    o < 0 || (s === 1 ? this._listeners.delete(e) : i.splice(o, 1));
  }
};
var H = "generated";
var Ue = "pointerdown";
var $e = "pointerup";
var ue = "pointerleave";
var qe = "pointerout";
var fe = "pointermove";
var Ge = "touchstart";
var de = "touchend";
var Ne = "touchmove";
var Xe = "touchcancel";
var Ye = "resize";
var Je = "visibilitychange";
var F = "tsParticles - Error";
var M = class {
  constructor(e, t, i) {
    if (this._updateFromAngle = (s, o) => {
      this.x = Math.cos(s) * o, this.y = Math.sin(s) * o;
    }, typeof e != "number" && e) {
      this.x = e.x, this.y = e.y;
      const s = e;
      this.z = s.z ? s.z : 0;
    } else if (e !== void 0 && t !== void 0)
      this.x = e, this.y = t, this.z = i != null ? i : 0;
    else
      throw new Error(`${F} Vector3d not initialized correctly`);
  }
  static get origin() {
    return M.create(0, 0, 0);
  }
  get angle() {
    return Math.atan2(this.y, this.x);
  }
  set angle(e) {
    this._updateFromAngle(e, this.length);
  }
  get length() {
    return Math.sqrt(this.getLengthSq());
  }
  set length(e) {
    this._updateFromAngle(this.angle, e);
  }
  static clone(e) {
    return M.create(e.x, e.y, e.z);
  }
  static create(e, t, i) {
    return new M(e, t, i);
  }
  add(e) {
    return M.create(this.x + e.x, this.y + e.y, this.z + e.z);
  }
  addTo(e) {
    this.x += e.x, this.y += e.y, this.z += e.z;
  }
  copy() {
    return M.clone(this);
  }
  distanceTo(e) {
    return this.sub(e).length;
  }
  distanceToSq(e) {
    return this.sub(e).getLengthSq();
  }
  div(e) {
    return M.create(this.x / e, this.y / e, this.z / e);
  }
  divTo(e) {
    this.x /= e, this.y /= e, this.z /= e;
  }
  getLengthSq() {
    return this.x ** 2 + this.y ** 2;
  }
  mult(e) {
    return M.create(this.x * e, this.y * e, this.z * e);
  }
  multTo(e) {
    this.x *= e, this.y *= e, this.z *= e;
  }
  rotate(e) {
    return M.create(this.x * Math.cos(e) - this.y * Math.sin(e), this.x * Math.sin(e) + this.y * Math.cos(e), 0);
  }
  setTo(e) {
    this.x = e.x, this.y = e.y;
    const t = e;
    this.z = t.z ? t.z : 0;
  }
  sub(e) {
    return M.create(this.x - e.x, this.y - e.y, this.z - e.z);
  }
  subFrom(e) {
    this.x -= e.x, this.y -= e.y, this.z -= e.z;
  }
};
var D = class extends M {
  constructor(e, t) {
    super(e, t, 0);
  }
  static get origin() {
    return D.create(0, 0);
  }
  static clone(e) {
    return D.create(e.x, e.y);
  }
  static create(e, t) {
    return new D(e, t);
  }
};
var Ze = Math.random;
function S() {
  return Pe(Ze(), 0, 1 - 1e-16);
}
function Pe(n, e, t) {
  return Math.min(Math.max(n, e), t);
}
function A(n) {
  const e = re(n);
  let t = oe(n);
  return e === t && (t = 0), S() * (e - t) + t;
}
function g(n) {
  return typeof n == "number" ? n : A(n);
}
function oe(n) {
  return typeof n == "number" ? n : n.min;
}
function re(n) {
  return typeof n == "number" ? n : n.max;
}
function p(n, e) {
  if (n === e || e === void 0 && typeof n == "number")
    return n;
  const t = oe(n), i = re(n);
  return e !== void 0 ? {
    min: Math.min(t, e),
    max: Math.max(i, e)
  } : p(t, i);
}
function je(n) {
  const e = n.random, { enable: t, minimumValue: i } = typeof e == "boolean" ? {
    enable: e,
    minimumValue: 0
  } : e;
  return g(t ? p(n.value, i) : n.value);
}
function Qe(n, e) {
  const t = n.x - e.x, i = n.y - e.y;
  return { dx: t, dy: i, distance: Math.sqrt(t ** 2 + i ** 2) };
}
function ae(n, e) {
  return Qe(n, e).distance;
}
function Ke(n, e, t) {
  if (typeof n == "number")
    return n * Math.PI / 180;
  switch (n) {
    case "top":
      return -Math.PI / 2;
    case "top-right":
      return -Math.PI / 4;
    case "right":
      return 0;
    case "bottom-right":
      return Math.PI / 4;
    case "bottom":
      return Math.PI / 2;
    case "bottom-left":
      return 3 * Math.PI / 4;
    case "left":
      return Math.PI;
    case "top-left":
      return -3 * Math.PI / 4;
    case "inside":
      return Math.atan2(t.y - e.y, t.x - e.x);
    case "outside":
      return Math.atan2(e.y - t.y, e.x - t.x);
    default:
      return S() * Math.PI * 2;
  }
}
function et(n) {
  const e = D.origin;
  return e.length = 1, e.angle = n, e;
}
function tt(n) {
  return n.position && n.position.x !== void 0 && n.position.y !== void 0 ? {
    x: n.position.x * n.size.width / 100,
    y: n.position.y * n.size.height / 100
  } : void 0;
}
function it(n) {
  var _a, _b;
  var e, t;
  return {
    x: (_a = (e = n.position) == null ? void 0 : e.x) != null ? _a : S() * n.size.width,
    y: (_b = (t = n.position) == null ? void 0 : t.y) != null ? _b : S() * n.size.height
  };
}
function ke(n) {
  return n ? n.endsWith("%") ? parseFloat(n) / 100 : parseFloat(n) : 1;
}
function V() {
  return typeof window > "u" || !window || typeof window.document > "u" || !window.document;
}
function st() {
  return !V() && typeof matchMedia < "u";
}
function Oe(n) {
  if (st())
    return matchMedia(n);
}
function nt() {
  return V() ? (n) => setTimeout(n) : (n) => (requestAnimationFrame || setTimeout)(n);
}
function ot() {
  return V() ? (n) => clearTimeout(n) : (n) => (cancelAnimationFrame || clearTimeout)(n);
}
function rt(n, e) {
  return n === e || e instanceof Array && e.indexOf(n) > -1;
}
function at(n) {
  return Math.floor(S() * n.length);
}
function he(n, e, t = true) {
  return n[e !== void 0 && t ? e % n.length : at(n)];
}
function _(n, ...e) {
  for (const t of e) {
    if (t == null)
      continue;
    if (typeof t != "object") {
      n = t;
      continue;
    }
    const i = Array.isArray(t);
    i && (typeof n != "object" || !n || !Array.isArray(n)) ? n = [] : !i && (typeof n != "object" || !n || Array.isArray(n)) && (n = {});
    for (const s in t) {
      if (s === "__proto__")
        continue;
      const o = t, r = o[s], a = typeof r == "object", h = n;
      h[s] = a && Array.isArray(r) ? r.map((l) => _(h[s], l)) : _(h[s], r);
    }
  }
  return n;
}
function T(n, e) {
  return n instanceof Array ? n.map((t, i) => e(t, i)) : e(n, 0);
}
function B(n, e, t) {
  return n instanceof Array ? he(n, e, t) : n;
}
function ht(n, e) {
  const t = n.value, i = n.animation, s = {
    delayTime: g(i.delay) * 1e3,
    enable: i.enable,
    value: g(n.value) * e,
    max: re(t) * e,
    min: oe(t) * e,
    loops: 0,
    maxLoops: g(i.count),
    time: 0
  };
  if (i.enable) {
    switch (s.decay = 1 - g(i.decay), i.mode) {
      case "increase":
        s.status = "increasing";
        break;
      case "decrease":
        s.status = "decreasing";
        break;
      case "random":
        s.status = S() >= 0.5 ? "increasing" : "decreasing";
        break;
    }
    const o = i.mode === "auto";
    switch (i.startValue) {
      case "min":
        s.value = s.min, o && (s.status = "increasing");
        break;
      case "max":
        s.value = s.max, o && (s.status = "decreasing");
        break;
      case "random":
      default:
        s.value = A(s), o && (s.status = S() >= 0.5 ? "increasing" : "decreasing");
        break;
    }
  }
  return s.initialValue = s.value, s;
}
var lt = "random";
var X = /* @__PURE__ */ new Map();
function Ce(n) {
  X.set(n.key, n);
}
function Y(n, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * (2 / 3 - t) * 6 : n;
}
function ct(n) {
  for (const [, o] of X)
    if (n.startsWith(o.stringPrefix))
      return o.parseString(n);
  const e = /^#?([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i, t = n.replace(e, (o, r, a, h, l) => r + r + a + a + h + h + (l !== void 0 ? l + l : "")), i = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i, s = i.exec(t);
  return s ? {
    a: s[4] !== void 0 ? parseInt(s[4], 16) / 255 : 1,
    b: parseInt(s[3], 16),
    g: parseInt(s[2], 16),
    r: parseInt(s[1], 16)
  } : void 0;
}
function L(n, e, t = true) {
  if (!n)
    return;
  const i = typeof n == "string" ? { value: n } : n;
  if (typeof i.value == "string")
    return Se(i.value, e, t);
  if (i.value instanceof Array)
    return L({
      value: he(i.value, e, t)
    });
  for (const [, s] of X) {
    const o = s.handleRangeColor(i);
    if (o)
      return o;
  }
}
function Se(n, e, t = true) {
  if (!n)
    return;
  const i = typeof n == "string" ? { value: n } : n;
  if (typeof i.value == "string")
    return i.value === lt ? pt() : ft(i.value);
  if (i.value instanceof Array)
    return Se({
      value: he(i.value, e, t)
    });
  for (const [, s] of X) {
    const o = s.handleColor(i);
    if (o)
      return o;
  }
}
function pe(n, e, t = true) {
  const i = L(n, e, t);
  return i ? ut(i) : void 0;
}
function ut(n) {
  const e = n.r / 255, t = n.g / 255, i = n.b / 255, s = Math.max(e, t, i), o = Math.min(e, t, i), r = {
    h: 0,
    l: (s + o) / 2,
    s: 0
  };
  return s !== o && (r.s = r.l < 0.5 ? (s - o) / (s + o) : (s - o) / (2 - s - o), r.h = e === s ? (t - i) / (s - o) : r.h = t === s ? 2 + (i - e) / (s - o) : 4 + (e - t) / (s - o)), r.l *= 100, r.s *= 100, r.h *= 60, r.h < 0 && (r.h += 360), r.h >= 360 && (r.h -= 360), r;
}
function ft(n) {
  return ct(n);
}
function ne(n) {
  const e = { b: 0, g: 0, r: 0 }, t = {
    h: n.h / 360,
    l: n.l / 100,
    s: n.s / 100
  };
  if (!t.s)
    e.r = e.g = e.b = t.l;
  else {
    const i = t.l < 0.5 ? t.l * (1 + t.s) : t.l + t.s - t.l * t.s, s = 2 * t.l - i;
    e.r = Y(s, i, t.h + 1 / 3), e.g = Y(s, i, t.h), e.b = Y(s, i, t.h - 1 / 3);
  }
  return e.r = Math.floor(e.r * 255), e.g = Math.floor(e.g * 255), e.b = Math.floor(e.b * 255), e;
}
function dt(n) {
  const e = ne(n);
  return {
    a: n.a,
    b: e.b,
    g: e.g,
    r: e.r
  };
}
function pt(n) {
  const e = n != null ? n : 0;
  return {
    b: Math.floor(A(p(e, 256))),
    g: Math.floor(A(p(e, 256))),
    r: Math.floor(A(p(e, 256)))
  };
}
function G(n, e) {
  return `rgba(${n.r}, ${n.g}, ${n.b}, ${e != null ? e : 1})`;
}
function me(n, e) {
  return `hsla(${n.h}, ${n.s}%, ${n.l}%, ${e != null ? e : 1})`;
}
function ge(n) {
  return n !== void 0 ? {
    h: n.h.value,
    s: n.s.value,
    l: n.l.value
  } : void 0;
}
function mt(n, e, t) {
  n.fillStyle = t != null ? t : "rgba(0,0,0,0)", n.fillRect(0, 0, e.width, e.height);
}
function gt(n, e, t, i) {
  t && (n.globalAlpha = i, n.drawImage(t, 0, 0, e.width, e.height), n.globalAlpha = 1);
}
function J(n, e) {
  n.clearRect(0, 0, e.width, e.height);
}
function yt(n) {
  var _a, _b, _c, _d, _e2;
  const { container: e, context: t, particle: i, delta: s, colorStyles: o, backgroundMask: r, composite: a, radius: h, opacity: l, shadow: c, transform: u } = n, d = i.getPosition(), f = i.rotation + (i.pathRotation ? i.velocity.angle : 0), y = {
    sin: Math.sin(f),
    cos: Math.cos(f)
  }, m = {
    a: y.cos * ((_a = u.a) != null ? _a : 1),
    b: y.sin * ((_b = u.b) != null ? _b : 1),
    c: -y.sin * ((_c = u.c) != null ? _c : 1),
    d: y.cos * ((_d = u.d) != null ? _d : 1)
  };
  t.setTransform(m.a, m.b, m.c, m.d, d.x, d.y), t.beginPath(), r && (t.globalCompositeOperation = a);
  const b = i.shadowColor;
  c.enable && b && (t.shadowBlur = c.blur, t.shadowColor = G(b), t.shadowOffsetX = c.offset.x, t.shadowOffsetY = c.offset.y), o.fill && (t.fillStyle = o.fill);
  const k = (_e2 = i.strokeWidth) != null ? _e2 : 0;
  t.lineWidth = k, o.stroke && (t.strokeStyle = o.stroke), vt(e, t, i, h, l, s), k > 0 && t.stroke(), i.close && t.closePath(), i.fill && t.fill(), _t(e, t, i, h, l, s), t.globalCompositeOperation = "source-over", t.setTransform(1, 0, 0, 1, 0, 0);
}
function vt(n, e, t, i, s, o) {
  if (!t.shape)
    return;
  const r = n.drawers.get(t.shape);
  r && r.draw(e, t, i, s, o, n.retina.pixelRatio);
}
function _t(n, e, t, i, s, o) {
  if (!t.shape)
    return;
  const r = n.drawers.get(t.shape);
  !r || !r.afterEffect || r.afterEffect(e, t, i, s, o, n.retina.pixelRatio);
}
function wt(n, e, t) {
  e.draw && e.draw(n, t);
}
function bt(n, e, t, i) {
  e.drawParticle && e.drawParticle(n, t, i);
}
function xt(n, e, t) {
  return {
    h: n.h,
    s: n.s,
    l: n.l + (e === "darken" ? -1 : 1) * t
  };
}
function zt(n, e, t) {
  var _a;
  const i = e[t];
  i !== void 0 && (n[t] = ((_a = n[t]) != null ? _a : 1) * i);
}
var Mt = class {
  constructor(e) {
    this.container = e, this._applyPostDrawUpdaters = (t) => {
      for (const i of this._postDrawUpdaters)
        i.afterDraw && i.afterDraw(t);
    }, this._applyPreDrawUpdaters = (t, i, s, o, r, a) => {
      for (const h of this._preDrawUpdaters) {
        if (h.getColorStyles) {
          const { fill: l, stroke: c } = h.getColorStyles(i, t, s, o);
          l && (r.fill = l), c && (r.stroke = c);
        }
        if (h.getTransformValues) {
          const l = h.getTransformValues(i);
          for (const c in l)
            zt(a, l, c);
        }
        h.beforeDraw && h.beforeDraw(i);
      }
    }, this._applyResizePlugins = () => {
      for (const t of this._resizePlugins)
        t.resize && t.resize();
    }, this._getPluginParticleColors = (t) => {
      let i, s;
      for (const o of this._colorPlugins)
        if (!i && o.particleFillColor && (i = pe(o.particleFillColor(t))), !s && o.particleStrokeColor && (s = pe(o.particleStrokeColor(t))), i && s)
          break;
      return [i, s];
    }, this._initCover = () => {
      const t = this.container.actualOptions, i = t.backgroundMask.cover, s = i.color, o = L(s);
      if (o) {
        const r = {
          ...o,
          a: i.opacity
        };
        this._coverColorStyle = G(r, r.a);
      }
    }, this._initStyle = () => {
      const t = this.element, i = this.container.actualOptions;
      if (t) {
        this._fullScreen ? (this._originalStyle = _({}, t.style), this._setFullScreenStyle()) : this._resetOriginalStyle();
        for (const s in i.style) {
          if (!s || !i.style)
            continue;
          const o = i.style[s];
          o && t.style.setProperty(s, o, "important");
        }
      }
    }, this._initTrail = async () => {
      const t = this.container.actualOptions, i = t.particles.move.trail, s = i.fill;
      if (i.enable)
        if (s.color) {
          const o = L(s.color);
          if (!o)
            return;
          const r = t.particles.move.trail;
          this._trailFill = {
            color: {
              ...o
            },
            opacity: 1 / r.length
          };
        } else
          await new Promise((o, r) => {
            if (!s.image)
              return;
            const a = document.createElement("img");
            a.addEventListener("load", () => {
              this._trailFill = {
                image: a,
                opacity: 1 / i.length
              }, o();
            }), a.addEventListener("error", (h) => {
              r(h.error);
            }), a.src = s.image;
          });
    }, this._paintBase = (t) => {
      this.draw((i) => mt(i, this.size, t));
    }, this._paintImage = (t, i) => {
      this.draw((s) => gt(s, this.size, t, i));
    }, this._repairStyle = () => {
      const t = this.element;
      t && (this._safeMutationObserver((i) => i.disconnect()), this._initStyle(), this.initBackground(), this._safeMutationObserver((i) => i.observe(t, { attributes: true })));
    }, this._resetOriginalStyle = () => {
      const t = this.element, i = this._originalStyle;
      if (!(t && i))
        return;
      const s = t.style;
      s.position = i.position, s.zIndex = i.zIndex, s.top = i.top, s.left = i.left, s.width = i.width, s.height = i.height;
    }, this._safeMutationObserver = (t) => {
      this._mutationObserver && t(this._mutationObserver);
    }, this._setFullScreenStyle = () => {
      const t = this.element;
      if (!t)
        return;
      const i = "important", s = t.style;
      s.setProperty("position", "fixed", i), s.setProperty("z-index", this.container.actualOptions.fullScreen.zIndex.toString(10), i), s.setProperty("top", "0", i), s.setProperty("left", "0", i), s.setProperty("width", "100%", i), s.setProperty("height", "100%", i);
    }, this.size = {
      height: 0,
      width: 0
    }, this._context = null, this._generated = false, this._preDrawUpdaters = [], this._postDrawUpdaters = [], this._resizePlugins = [], this._colorPlugins = [], this._mutationObserver = !V() && typeof MutationObserver < "u" ? new MutationObserver((t) => {
      for (const i of t)
        i.type === "attributes" && i.attributeName === "style" && this._repairStyle();
    }) : void 0;
  }
  get _fullScreen() {
    return this.container.actualOptions.fullScreen.enable;
  }
  clear() {
    const e = this.container.actualOptions, t = e.particles.move.trail, i = this._trailFill;
    e.backgroundMask.enable ? this.paint() : t.enable && t.length > 0 && i ? i.color ? this._paintBase(G(i.color, i.opacity)) : i.image && this._paintImage(i.image, i.opacity) : this.draw((s) => {
      J(s, this.size);
    });
  }
  destroy() {
    if (this._safeMutationObserver((e) => e.disconnect()), this._generated) {
      const e = this.element;
      e && e.remove();
    } else
      this._resetOriginalStyle();
    this.stop(), this._preDrawUpdaters = [], this._postDrawUpdaters = [], this._resizePlugins = [], this._colorPlugins = [];
  }
  draw(e) {
    const t = this._context;
    if (t)
      return e(t);
  }
  drawParticle(e, t) {
    var _a;
    if (e.spawning || e.destroyed)
      return;
    const i = e.getRadius();
    if (i <= 0)
      return;
    const s = e.getFillColor(), o = (_a = e.getStrokeColor()) != null ? _a : s;
    let [r, a] = this._getPluginParticleColors(e);
    r || (r = s), a || (a = o), !(!r && !a) && this.draw((h) => {
      var _a2, _b, _c;
      var x;
      const l = this.container, c = l.actualOptions, u = e.options.zIndex, d = (1 - e.zIndexFactor) ** u.opacityRate, f = (_b = (_a2 = e.bubble.opacity) != null ? _a2 : (x = e.opacity) == null ? void 0 : x.value) != null ? _b : 1, y = (_c = e.strokeOpacity) != null ? _c : f, m = f * d, b = y * d, k = {}, w = {
        fill: r ? me(r, m) : void 0
      };
      w.stroke = a ? me(a, b) : w.fill, this._applyPreDrawUpdaters(h, e, i, m, w, k), yt({
        container: l,
        context: h,
        particle: e,
        delta: t,
        colorStyles: w,
        backgroundMask: c.backgroundMask.enable,
        composite: c.backgroundMask.composite,
        radius: i * (1 - e.zIndexFactor) ** u.sizeRate,
        opacity: m,
        shadow: e.options.shadow,
        transform: k
      }), this._applyPostDrawUpdaters(e);
    });
  }
  drawParticlePlugin(e, t, i) {
    this.draw((s) => bt(s, e, t, i));
  }
  drawPlugin(e, t) {
    this.draw((i) => wt(i, e, t));
  }
  async init() {
    this.resize(), this._initStyle(), this._initCover();
    try {
      await this._initTrail();
    } catch (e) {
      console.error(e);
    }
    this.initBackground(), this._safeMutationObserver((e) => {
      this.element && e.observe(this.element, { attributes: true });
    }), this.initUpdaters(), this.initPlugins(), this.paint();
  }
  initBackground() {
    const e = this.container.actualOptions, t = e.background, i = this.element;
    if (!i)
      return;
    const s = i.style;
    if (s) {
      if (t.color) {
        const o = L(t.color);
        s.backgroundColor = o ? G(o, t.opacity) : "";
      } else
        s.backgroundColor = "";
      s.backgroundImage = t.image || "", s.backgroundPosition = t.position || "", s.backgroundRepeat = t.repeat || "", s.backgroundSize = t.size || "";
    }
  }
  initPlugins() {
    this._resizePlugins = [];
    for (const [, e] of this.container.plugins)
      e.resize && this._resizePlugins.push(e), (e.particleFillColor || e.particleStrokeColor) && this._colorPlugins.push(e);
  }
  initUpdaters() {
    this._preDrawUpdaters = [], this._postDrawUpdaters = [];
    for (const e of this.container.particles.updaters)
      e.afterDraw && this._postDrawUpdaters.push(e), (e.getColorStyles || e.getTransformValues || e.beforeDraw) && this._preDrawUpdaters.push(e);
  }
  loadCanvas(e) {
    this._generated && this.element && this.element.remove(), this._generated = e.dataset && H in e.dataset ? e.dataset[H] === "true" : this._generated, this.element = e, this.element.ariaHidden = "true", this._originalStyle = _({}, this.element.style), this.size.height = e.offsetHeight, this.size.width = e.offsetWidth, this._context = this.element.getContext("2d"), this._safeMutationObserver((t) => {
      this.element && t.observe(this.element, { attributes: true });
    }), this.container.retina.init(), this.initBackground();
  }
  paint() {
    const e = this.container.actualOptions;
    this.draw((t) => {
      e.backgroundMask.enable && e.backgroundMask.cover ? (J(t, this.size), this._paintBase(this._coverColorStyle)) : this._paintBase();
    });
  }
  resize() {
    if (!this.element)
      return false;
    const e = this.container, t = e.retina.pixelRatio, i = e.canvas.size, s = {
      width: this.element.offsetWidth * t,
      height: this.element.offsetHeight * t
    };
    if (s.height === i.height && s.width === i.width && s.height === this.element.height && s.width === this.element.width)
      return false;
    const o = { ...i };
    return this.element.width = i.width = this.element.offsetWidth * t, this.element.height = i.height = this.element.offsetHeight * t, this.container.started && (this.resizeFactor = {
      width: i.width / o.width,
      height: i.height / o.height
    }), true;
  }
  stop() {
    this.draw((e) => J(e, this.size));
  }
  async windowResize() {
    if (!this.element || !this.resize())
      return;
    const e = this.container, t = e.updateActualOptions();
    e.particles.setDensity(), this._applyResizePlugins(), t && await e.refresh();
  }
};
function P(n, e, t, i, s) {
  if (i) {
    let o = { passive: true };
    typeof s == "boolean" ? o.capture = s : s !== void 0 && (o = s), n.addEventListener(e, t, o);
  } else {
    const o = s;
    n.removeEventListener(e, t, o);
  }
}
var Pt = class {
  constructor(e) {
    this.container = e, this._doMouseTouchClick = (t) => {
      const i = this.container, s = i.actualOptions;
      if (this._canPush) {
        const o = i.interactivity.mouse, r = o.position;
        if (!r)
          return;
        o.clickPosition = { ...r }, o.clickTime = new Date().getTime();
        const a = s.interactivity.events.onClick;
        T(a.mode, (h) => this.container.handleClickMode(h));
      }
      t.type === "touchend" && setTimeout(() => this._mouseTouchFinish(), 500);
    }, this._handleThemeChange = (t) => {
      const i = t, s = this.container, o = s.options, r = o.defaultThemes, a = i.matches ? r.dark : r.light, h = o.themes.find((l) => l.name === a);
      h && h.default.auto && s.loadTheme(a);
    }, this._handleVisibilityChange = () => {
      const t = this.container, i = t.actualOptions;
      this._mouseTouchFinish(), i.pauseOnBlur && (document && document.hidden ? (t.pageHidden = true, t.pause()) : (t.pageHidden = false, t.getAnimationStatus() ? t.play(true) : t.draw(true)));
    }, this._handleWindowResize = async () => {
      this._resizeTimeout && (clearTimeout(this._resizeTimeout), delete this._resizeTimeout), this._resizeTimeout = setTimeout(async () => {
        const t = this.container.canvas;
        t && await t.windowResize();
      }, this.container.actualOptions.interactivity.events.resize.delay * 1e3);
    }, this._manageInteractivityListeners = (t, i) => {
      const s = this._handlers, o = this.container, r = o.actualOptions, a = o.interactivity.element;
      if (!a)
        return;
      const h = a, l = o.canvas.element;
      l && (l.style.pointerEvents = h === l ? "initial" : "none"), (r.interactivity.events.onHover.enable || r.interactivity.events.onClick.enable) && (P(a, fe, s.mouseMove, i), P(a, Ge, s.touchStart, i), P(a, Ne, s.touchMove, i), r.interactivity.events.onClick.enable ? (P(a, de, s.touchEndClick, i), P(a, $e, s.mouseUp, i), P(a, Ue, s.mouseDown, i)) : P(a, de, s.touchEnd, i), P(a, t, s.mouseLeave, i), P(a, Xe, s.touchCancel, i));
    }, this._manageListeners = (t) => {
      var _a;
      const i = this._handlers, s = this.container, o = s.actualOptions, r = o.interactivity.detectsOn, a = s.canvas.element;
      let h = ue;
      r === "window" ? (s.interactivity.element = window, h = qe) : r === "parent" && a ? s.interactivity.element = (_a = a.parentElement) != null ? _a : a.parentNode : s.interactivity.element = a, this._manageMediaMatch(t), this._manageResize(t), this._manageInteractivityListeners(h, t), document && P(document, Je, i.visibilityChange, t, false);
    }, this._manageMediaMatch = (t) => {
      const i = this._handlers, s = Oe("(prefers-color-scheme: dark)");
      if (s) {
        if (s.addEventListener !== void 0) {
          P(s, "change", i.themeChange, t);
          return;
        }
        s.addListener !== void 0 && (t ? s.addListener(i.oldThemeChange) : s.removeListener(i.oldThemeChange));
      }
    }, this._manageResize = (t) => {
      const i = this._handlers, s = this.container;
      if (!s.actualOptions.interactivity.events.resize)
        return;
      if (typeof ResizeObserver > "u") {
        P(window, Ye, i.resize, t);
        return;
      }
      const r = s.canvas.element;
      this._resizeObserver && !t ? (r && this._resizeObserver.unobserve(r), this._resizeObserver.disconnect(), delete this._resizeObserver) : !this._resizeObserver && t && r && (this._resizeObserver = new ResizeObserver(async (a) => {
        a.find((l) => l.target === r) && await this._handleWindowResize();
      }), this._resizeObserver.observe(r));
    }, this._mouseDown = () => {
      const { interactivity: t } = this.container;
      if (!t)
        return;
      const { mouse: i } = t;
      i.clicking = true, i.downPosition = i.position;
    }, this._mouseTouchClick = (t) => {
      const i = this.container, s = i.actualOptions, { mouse: o } = i.interactivity;
      o.inside = true;
      let r = false;
      const a = o.position;
      if (!(!a || !s.interactivity.events.onClick.enable)) {
        for (const [, h] of i.plugins)
          if (h.clickPositionValid && (r = h.clickPositionValid(a), r))
            break;
        r || this._doMouseTouchClick(t), o.clicking = false;
      }
    }, this._mouseTouchFinish = () => {
      const t = this.container.interactivity;
      if (!t)
        return;
      const i = t.mouse;
      delete i.position, delete i.clickPosition, delete i.downPosition, t.status = ue, i.inside = false, i.clicking = false;
    }, this._mouseTouchMove = (t) => {
      var _a, _b, _c, _d, _e2, _f;
      const i = this.container, s = i.actualOptions, o = i.interactivity, r = i.canvas.element;
      if (!o || !o.element)
        return;
      o.mouse.inside = true;
      let a;
      if (t.type.startsWith("pointer")) {
        this._canPush = true;
        const l = t;
        if (o.element === window) {
          if (r) {
            const c = r.getBoundingClientRect();
            a = {
              x: l.clientX - c.left,
              y: l.clientY - c.top
            };
          }
        } else if (s.interactivity.detectsOn === "parent") {
          const c = l.target, u = l.currentTarget;
          if (c && u && r) {
            const d = c.getBoundingClientRect(), f = u.getBoundingClientRect(), y = r.getBoundingClientRect();
            a = {
              x: l.offsetX + 2 * d.left - (f.left + y.left),
              y: l.offsetY + 2 * d.top - (f.top + y.top)
            };
          } else
            a = {
              x: (_a = l.offsetX) != null ? _a : l.clientX,
              y: (_b = l.offsetY) != null ? _b : l.clientY
            };
        } else
          l.target === r && (a = {
            x: (_c = l.offsetX) != null ? _c : l.clientX,
            y: (_d = l.offsetY) != null ? _d : l.clientY
          });
      } else if (this._canPush = t.type !== "touchmove", r) {
        const l = t, c = l.touches[l.touches.length - 1], u = r.getBoundingClientRect();
        a = {
          x: c.clientX - ((_e2 = u.left) != null ? _e2 : 0),
          y: c.clientY - ((_f = u.top) != null ? _f : 0)
        };
      }
      const h = i.retina.pixelRatio;
      a && (a.x *= h, a.y *= h), o.mouse.position = a, o.status = fe;
    }, this._touchEnd = (t) => {
      const i = t, s = Array.from(i.changedTouches);
      for (const o of s)
        this._touches.delete(o.identifier);
      this._mouseTouchFinish();
    }, this._touchEndClick = (t) => {
      const i = t, s = Array.from(i.changedTouches);
      for (const o of s)
        this._touches.delete(o.identifier);
      this._mouseTouchClick(t);
    }, this._touchStart = (t) => {
      const i = t, s = Array.from(i.changedTouches);
      for (const o of s)
        this._touches.set(o.identifier, performance.now());
      this._mouseTouchMove(t);
    }, this._canPush = true, this._touches = /* @__PURE__ */ new Map(), this._handlers = {
      mouseDown: () => this._mouseDown(),
      mouseLeave: () => this._mouseTouchFinish(),
      mouseMove: (t) => this._mouseTouchMove(t),
      mouseUp: (t) => this._mouseTouchClick(t),
      touchStart: (t) => this._touchStart(t),
      touchMove: (t) => this._mouseTouchMove(t),
      touchEnd: (t) => this._touchEnd(t),
      touchCancel: (t) => this._touchEnd(t),
      touchEndClick: (t) => this._touchEndClick(t),
      visibilityChange: () => this._handleVisibilityChange(),
      themeChange: (t) => this._handleThemeChange(t),
      oldThemeChange: (t) => this._handleThemeChange(t),
      resize: () => {
        this._handleWindowResize();
      }
    };
  }
  addListeners() {
    this._manageListeners(true);
  }
  removeListeners() {
    this._manageListeners(false);
  }
};
function kt(n, e = 60, t = false) {
  return {
    value: n,
    factor: t ? 60 / e : 60 * n / 1e3
  };
}
var Ot = class {
  constructor(e) {
    this.container = e;
  }
  async nextFrame(e) {
    var _a;
    try {
      const t = this.container;
      if (!t.smooth && t.lastFrameTime !== void 0 && e < t.lastFrameTime + 1e3 / t.fpsLimit) {
        t.draw(false);
        return;
      }
      (_a = t.lastFrameTime) != null ? _a : t.lastFrameTime = e;
      const i = kt(e - t.lastFrameTime, t.fpsLimit, t.smooth);
      if (t.addLifeTime(i.value), t.lastFrameTime = e, i.value > 1e3) {
        t.draw(false);
        return;
      }
      if (await t.particles.draw(i), !t.alive()) {
        t.destroy();
        return;
      }
      t.getAnimationStatus() && t.draw(false);
    } catch (t) {
      console.error(`${F} in animation loop`, t);
    }
  }
};
var O = class {
  constructor() {
    this.value = "";
  }
  static create(e, t) {
    const i = new O();
    return i.load(e), t !== void 0 && (typeof t == "string" || t instanceof Array ? i.load({ value: t }) : i.load(t)), i;
  }
  load(e) {
    (e == null ? void 0 : e.value) !== void 0 && (this.value = e.value);
  }
};
var Ct = class {
  constructor() {
    this.color = new O(), this.color.value = "", this.image = "", this.position = "", this.repeat = "", this.size = "", this.opacity = 1;
  }
  load(e) {
    e && (e.color !== void 0 && (this.color = O.create(this.color, e.color)), e.image !== void 0 && (this.image = e.image), e.position !== void 0 && (this.position = e.position), e.repeat !== void 0 && (this.repeat = e.repeat), e.size !== void 0 && (this.size = e.size), e.opacity !== void 0 && (this.opacity = e.opacity));
  }
};
var St = class {
  constructor() {
    this.color = new O(), this.color.value = "#fff", this.opacity = 1;
  }
  load(e) {
    e && (e.color !== void 0 && (this.color = O.create(this.color, e.color)), e.opacity !== void 0 && (this.opacity = e.opacity));
  }
};
var Tt = class {
  constructor() {
    this.composite = "destination-out", this.cover = new St(), this.enable = false;
  }
  load(e) {
    if (e) {
      if (e.composite !== void 0 && (this.composite = e.composite), e.cover !== void 0) {
        const t = e.cover, i = typeof e.cover == "string" ? { color: e.cover } : e.cover;
        this.cover.load(t.color !== void 0 ? t : { color: i });
      }
      e.enable !== void 0 && (this.enable = e.enable);
    }
  }
};
var Rt = class {
  constructor() {
    this.enable = true, this.zIndex = 0;
  }
  load(e) {
    e && (e.enable !== void 0 && (this.enable = e.enable), e.zIndex !== void 0 && (this.zIndex = e.zIndex));
  }
};
var It = class {
  constructor() {
    this.enable = false, this.mode = [];
  }
  load(e) {
    e && (e.enable !== void 0 && (this.enable = e.enable), e.mode !== void 0 && (this.mode = e.mode));
  }
};
var ye = class {
  constructor() {
    this.selectors = [], this.enable = false, this.mode = [], this.type = "circle";
  }
  get el() {
    return this.elementId;
  }
  set el(e) {
    this.elementId = e;
  }
  get elementId() {
    return this.ids;
  }
  set elementId(e) {
    this.ids = e;
  }
  get ids() {
    return T(this.selectors, (e) => e.replace("#", ""));
  }
  set ids(e) {
    this.selectors = T(e, (t) => `#${t}`);
  }
  load(e) {
    var _a, _b;
    if (!e)
      return;
    const t = (_b = (_a = e.ids) != null ? _a : e.elementId) != null ? _b : e.el;
    t !== void 0 && (this.ids = t), e.selectors !== void 0 && (this.selectors = e.selectors), e.enable !== void 0 && (this.enable = e.enable), e.mode !== void 0 && (this.mode = e.mode), e.type !== void 0 && (this.type = e.type);
  }
};
var Et = class {
  constructor() {
    this.enable = false, this.force = 2, this.smooth = 10;
  }
  load(e) {
    e && (e.enable !== void 0 && (this.enable = e.enable), e.force !== void 0 && (this.force = e.force), e.smooth !== void 0 && (this.smooth = e.smooth));
  }
};
var Dt = class {
  constructor() {
    this.enable = false, this.mode = [], this.parallax = new Et();
  }
  load(e) {
    e && (e.enable !== void 0 && (this.enable = e.enable), e.mode !== void 0 && (this.mode = e.mode), this.parallax.load(e.parallax));
  }
};
var At = class {
  constructor() {
    this.delay = 0.5, this.enable = true;
  }
  load(e) {
    e !== void 0 && (e.delay !== void 0 && (this.delay = e.delay), e.enable !== void 0 && (this.enable = e.enable));
  }
};
var Lt = class {
  constructor() {
    this.onClick = new It(), this.onDiv = new ye(), this.onHover = new Dt(), this.resize = new At();
  }
  get onclick() {
    return this.onClick;
  }
  set onclick(e) {
    this.onClick = e;
  }
  get ondiv() {
    return this.onDiv;
  }
  set ondiv(e) {
    this.onDiv = e;
  }
  get onhover() {
    return this.onHover;
  }
  set onhover(e) {
    this.onHover = e;
  }
  load(e) {
    var _a, _b, _c;
    if (!e)
      return;
    this.onClick.load((_a = e.onClick) != null ? _a : e.onclick);
    const t = (_b = e.onDiv) != null ? _b : e.ondiv;
    t !== void 0 && (this.onDiv = T(t, (i) => {
      const s = new ye();
      return s.load(i), s;
    })), this.onHover.load((_c = e.onHover) != null ? _c : e.onhover), typeof e.resize == "boolean" ? this.resize.enable = e.resize : this.resize.load(e.resize);
  }
};
var Ft = class {
  constructor(e, t) {
    this._engine = e, this._container = t;
  }
  load(e) {
    if (!e || !this._container)
      return;
    const t = this._engine.plugins.interactors.get(this._container);
    if (t)
      for (const i of t)
        i.loadModeOptions && i.loadModeOptions(this, e);
  }
};
var Te = class {
  constructor(e, t) {
    this.detectsOn = "window", this.events = new Lt(), this.modes = new Ft(e, t);
  }
  get detect_on() {
    return this.detectsOn;
  }
  set detect_on(e) {
    this.detectsOn = e;
  }
  load(e) {
    var _a;
    if (!e)
      return;
    const t = (_a = e.detectsOn) != null ? _a : e.detect_on;
    t !== void 0 && (this.detectsOn = t), this.events.load(e.events), this.modes.load(e.modes);
  }
};
var Vt = class {
  load(e) {
    var _a, _b, _c;
    e && (e.position && (this.position = {
      x: (_a = e.position.x) != null ? _a : 50,
      y: (_b = e.position.y) != null ? _b : 50,
      mode: (_c = e.position.mode) != null ? _c : "percent"
    }), e.options && (this.options = _({}, e.options)));
  }
};
var Ht = class {
  constructor() {
    this.maxWidth = 1 / 0, this.options = {}, this.mode = "canvas";
  }
  load(e) {
    e && (e.maxWidth !== void 0 && (this.maxWidth = e.maxWidth), e.mode !== void 0 && (e.mode === "screen" ? this.mode = "screen" : this.mode = "canvas"), e.options !== void 0 && (this.options = _({}, e.options)));
  }
};
var Bt = class {
  constructor() {
    this.auto = false, this.mode = "any", this.value = false;
  }
  load(e) {
    e && (e.auto !== void 0 && (this.auto = e.auto), e.mode !== void 0 && (this.mode = e.mode), e.value !== void 0 && (this.value = e.value));
  }
};
var Wt = class {
  constructor() {
    this.name = "", this.default = new Bt();
  }
  load(e) {
    e && (e.name !== void 0 && (this.name = e.name), this.default.load(e.default), e.options !== void 0 && (this.options = _({}, e.options)));
  }
};
var Z = class {
  constructor() {
    this.count = 0, this.enable = false, this.offset = 0, this.speed = 1, this.delay = 0, this.decay = 0, this.sync = true;
  }
  load(e) {
    e && (e.count !== void 0 && (this.count = p(e.count)), e.enable !== void 0 && (this.enable = e.enable), e.offset !== void 0 && (this.offset = p(e.offset)), e.speed !== void 0 && (this.speed = p(e.speed)), e.decay !== void 0 && (this.decay = p(e.decay)), e.delay !== void 0 && (this.delay = p(e.delay)), e.sync !== void 0 && (this.sync = e.sync));
  }
};
var Ut = class {
  constructor() {
    this.h = new Z(), this.s = new Z(), this.l = new Z();
  }
  load(e) {
    e && (this.h.load(e.h), this.s.load(e.s), this.l.load(e.l));
  }
};
var W = class extends O {
  constructor() {
    super(), this.animation = new Ut();
  }
  static create(e, t) {
    const i = new W();
    return i.load(e), t !== void 0 && (typeof t == "string" || t instanceof Array ? i.load({ value: t }) : i.load(t)), i;
  }
  load(e) {
    if (super.load(e), !e)
      return;
    const t = e.animation;
    t !== void 0 && (t.enable !== void 0 ? this.animation.h.load(t) : this.animation.load(e.animation));
  }
};
var $t = class {
  constructor() {
    this.speed = 2;
  }
  load(e) {
    e && e.speed !== void 0 && (this.speed = e.speed);
  }
};
var qt = class {
  constructor() {
    this.enable = true, this.retries = 0;
  }
  load(e) {
    e && (e.enable !== void 0 && (this.enable = e.enable), e.retries !== void 0 && (this.retries = e.retries));
  }
};
var Gt = class {
  constructor() {
    this.count = 0, this.enable = false, this.speed = 1, this.decay = 0, this.delay = 0, this.sync = false;
  }
  load(e) {
    e && (e.count !== void 0 && (this.count = p(e.count)), e.enable !== void 0 && (this.enable = e.enable), e.speed !== void 0 && (this.speed = p(e.speed)), e.decay !== void 0 && (this.decay = p(e.decay)), e.delay !== void 0 && (this.delay = p(e.delay)), e.sync !== void 0 && (this.sync = e.sync));
  }
};
var Re = class extends Gt {
  constructor() {
    super(), this.mode = "auto", this.startValue = "random";
  }
  load(e) {
    super.load(e), e && (e.minimumValue !== void 0 && (this.minimumValue = e.minimumValue), e.mode !== void 0 && (this.mode = e.mode), e.startValue !== void 0 && (this.startValue = e.startValue));
  }
};
var Nt = class {
  constructor() {
    this.enable = false, this.minimumValue = 0;
  }
  load(e) {
    e && (e.enable !== void 0 && (this.enable = e.enable), e.minimumValue !== void 0 && (this.minimumValue = e.minimumValue));
  }
};
var $ = class {
  constructor() {
    this.random = new Nt(), this.value = 0;
  }
  load(e) {
    e && (typeof e.random == "boolean" ? this.random.enable = e.random : this.random.load(e.random), e.value !== void 0 && (this.value = p(e.value, this.random.enable ? this.random.minimumValue : void 0)));
  }
};
var ve = class extends $ {
  constructor() {
    super(), this.random.minimumValue = 0.1, this.value = 1;
  }
};
var Ie = class {
  constructor() {
    this.horizontal = new ve(), this.vertical = new ve();
  }
  load(e) {
    e && (this.horizontal.load(e.horizontal), this.vertical.load(e.vertical));
  }
};
var Xt = class {
  constructor() {
    this.absorb = new $t(), this.bounce = new Ie(), this.enable = false, this.maxSpeed = 50, this.mode = "bounce", this.overlap = new qt();
  }
  load(e) {
    e && (this.absorb.load(e.absorb), this.bounce.load(e.bounce), e.enable !== void 0 && (this.enable = e.enable), e.maxSpeed !== void 0 && (this.maxSpeed = p(e.maxSpeed)), e.mode !== void 0 && (this.mode = e.mode), this.overlap.load(e.overlap));
  }
};
var Yt = class {
  constructor() {
    this.offset = 0, this.value = 90;
  }
  load(e) {
    e && (e.offset !== void 0 && (this.offset = p(e.offset)), e.value !== void 0 && (this.value = p(e.value)));
  }
};
var Jt = class {
  constructor() {
    this.distance = 200, this.enable = false, this.rotate = {
      x: 3e3,
      y: 3e3
    };
  }
  get rotateX() {
    return this.rotate.x;
  }
  set rotateX(e) {
    this.rotate.x = e;
  }
  get rotateY() {
    return this.rotate.y;
  }
  set rotateY(e) {
    this.rotate.y = e;
  }
  load(e) {
    var _a, _b;
    var s, o;
    if (!e)
      return;
    e.distance !== void 0 && (this.distance = p(e.distance)), e.enable !== void 0 && (this.enable = e.enable);
    const t = (_a = (s = e.rotate) == null ? void 0 : s.x) != null ? _a : e.rotateX;
    t !== void 0 && (this.rotate.x = t);
    const i = (_b = (o = e.rotate) == null ? void 0 : o.y) != null ? _b : e.rotateY;
    i !== void 0 && (this.rotate.y = i);
  }
};
var Zt = class {
  constructor() {
    this.x = 50, this.y = 50, this.mode = "percent", this.radius = 0;
  }
  load(e) {
    e && (e.x !== void 0 && (this.x = e.x), e.y !== void 0 && (this.y = e.y), e.mode !== void 0 && (this.mode = e.mode), e.radius !== void 0 && (this.radius = e.radius));
  }
};
var jt = class {
  constructor() {
    this.acceleration = 9.81, this.enable = false, this.inverse = false, this.maxSpeed = 50;
  }
  load(e) {
    e && (e.acceleration !== void 0 && (this.acceleration = p(e.acceleration)), e.enable !== void 0 && (this.enable = e.enable), e.inverse !== void 0 && (this.inverse = e.inverse), e.maxSpeed !== void 0 && (this.maxSpeed = p(e.maxSpeed)));
  }
};
var Qt = class {
  constructor() {
    this.clamp = true, this.delay = new $(), this.enable = false, this.options = {};
  }
  load(e) {
    e && (e.clamp !== void 0 && (this.clamp = e.clamp), this.delay.load(e.delay), e.enable !== void 0 && (this.enable = e.enable), this.generator = e.generator, e.options && (this.options = _(this.options, e.options)));
  }
};
var Kt = class {
  load(e) {
    e && (e.color !== void 0 && (this.color = O.create(this.color, e.color)), e.image !== void 0 && (this.image = e.image));
  }
};
var ei = class {
  constructor() {
    this.enable = false, this.length = 10, this.fill = new Kt();
  }
  get fillColor() {
    return this.fill.color;
  }
  set fillColor(e) {
    this.fill.load({ color: e });
  }
  load(e) {
    e && (e.enable !== void 0 && (this.enable = e.enable), (e.fill !== void 0 || e.fillColor !== void 0) && this.fill.load(e.fill || { color: e.fillColor }), e.length !== void 0 && (this.length = e.length));
  }
};
var ti = class {
  constructor() {
    this.default = "out";
  }
  load(e) {
    var _a, _b, _c, _d;
    e && (e.default !== void 0 && (this.default = e.default), this.bottom = (_a = e.bottom) != null ? _a : e.default, this.left = (_b = e.left) != null ? _b : e.default, this.right = (_c = e.right) != null ? _c : e.default, this.top = (_d = e.top) != null ? _d : e.default);
  }
};
var ii = class {
  constructor() {
    this.acceleration = 0, this.enable = false;
  }
  load(e) {
    e && (e.acceleration !== void 0 && (this.acceleration = p(e.acceleration)), e.enable !== void 0 && (this.enable = e.enable), e.position && (this.position = _({}, e.position)));
  }
};
var si = class {
  constructor() {
    this.angle = new Yt(), this.attract = new Jt(), this.center = new Zt(), this.decay = 0, this.distance = {}, this.direction = "none", this.drift = 0, this.enable = false, this.gravity = new jt(), this.path = new Qt(), this.outModes = new ti(), this.random = false, this.size = false, this.speed = 2, this.spin = new ii(), this.straight = false, this.trail = new ei(), this.vibrate = false, this.warp = false;
  }
  get bounce() {
    return this.collisions;
  }
  set bounce(e) {
    this.collisions = e;
  }
  get collisions() {
    return false;
  }
  set collisions(e) {
  }
  get noise() {
    return this.path;
  }
  set noise(e) {
    this.path = e;
  }
  get outMode() {
    return this.outModes.default;
  }
  set outMode(e) {
    this.outModes.default = e;
  }
  get out_mode() {
    return this.outMode;
  }
  set out_mode(e) {
    this.outMode = e;
  }
  load(e) {
    var _a, _b, _c;
    if (!e)
      return;
    this.angle.load(typeof e.angle == "number" ? { value: e.angle } : e.angle), this.attract.load(e.attract), this.center.load(e.center), e.decay !== void 0 && (this.decay = p(e.decay)), e.direction !== void 0 && (this.direction = e.direction), e.distance !== void 0 && (this.distance = typeof e.distance == "number" ? {
      horizontal: e.distance,
      vertical: e.distance
    } : { ...e.distance }), e.drift !== void 0 && (this.drift = p(e.drift)), e.enable !== void 0 && (this.enable = e.enable), this.gravity.load(e.gravity);
    const t = (_b = (_a = e.outModes) != null ? _a : e.outMode) != null ? _b : e.out_mode;
    t !== void 0 && (typeof t == "object" ? this.outModes.load(t) : this.outModes.load({
      default: t
    })), this.path.load((_c = e.path) != null ? _c : e.noise), e.random !== void 0 && (this.random = e.random), e.size !== void 0 && (this.size = e.size), e.speed !== void 0 && (this.speed = p(e.speed)), this.spin.load(e.spin), e.straight !== void 0 && (this.straight = e.straight), this.trail.load(e.trail), e.vibrate !== void 0 && (this.vibrate = e.vibrate), e.warp !== void 0 && (this.warp = e.warp);
  }
};
var ni = class extends Re {
  constructor() {
    super(), this.destroy = "none", this.speed = 2;
  }
  get opacity_min() {
    return this.minimumValue;
  }
  set opacity_min(e) {
    this.minimumValue = e;
  }
  load(e) {
    (e == null ? void 0 : e.opacity_min) !== void 0 && e.minimumValue === void 0 && (e.minimumValue = e.opacity_min), super.load(e), e && e.destroy !== void 0 && (this.destroy = e.destroy);
  }
};
var oi = class extends $ {
  constructor() {
    super(), this.animation = new ni(), this.random.minimumValue = 0.1, this.value = 1;
  }
  get anim() {
    return this.animation;
  }
  set anim(e) {
    this.animation = e;
  }
  load(e) {
    var _a;
    if (!e)
      return;
    super.load(e);
    const t = (_a = e.animation) != null ? _a : e.anim;
    t !== void 0 && (this.animation.load(t), this.value = p(this.value, this.animation.enable ? this.animation.minimumValue : void 0));
  }
};
var ri = class {
  constructor() {
    this.enable = false, this.width = 1920, this.height = 1080;
  }
  get area() {
    return this.width;
  }
  set area(e) {
    this.width = e;
  }
  get factor() {
    return this.height;
  }
  set factor(e) {
    this.height = e;
  }
  get value_area() {
    return this.area;
  }
  set value_area(e) {
    this.area = e;
  }
  load(e) {
    var _a, _b, _c;
    if (!e)
      return;
    e.enable !== void 0 && (this.enable = e.enable);
    const t = (_b = (_a = e.width) != null ? _a : e.area) != null ? _b : e.value_area;
    t !== void 0 && (this.width = t);
    const i = (_c = e.height) != null ? _c : e.factor;
    i !== void 0 && (this.height = i);
  }
};
var ai = class {
  constructor() {
    this.density = new ri(), this.limit = 0, this.value = 0;
  }
  get max() {
    return this.limit;
  }
  set max(e) {
    this.limit = e;
  }
  load(e) {
    var _a;
    if (!e)
      return;
    this.density.load(e.density);
    const t = (_a = e.limit) != null ? _a : e.max;
    t !== void 0 && (this.limit = t), e.value !== void 0 && (this.value = e.value);
  }
};
var hi = class {
  constructor() {
    this.blur = 0, this.color = new O(), this.enable = false, this.offset = {
      x: 0,
      y: 0
    }, this.color.value = "#000";
  }
  load(e) {
    e && (e.blur !== void 0 && (this.blur = e.blur), this.color = O.create(this.color, e.color), e.enable !== void 0 && (this.enable = e.enable), e.offset !== void 0 && (e.offset.x !== void 0 && (this.offset.x = e.offset.x), e.offset.y !== void 0 && (this.offset.y = e.offset.y)));
  }
};
var j = "character";
var Q = "char";
var K = "image";
var ee = "images";
var te = "polygon";
var ie = "star";
var li = class {
  constructor() {
    this.loadShape = (e, t, i, s) => {
      var _a, _b;
      if (!e)
        return;
      const o = e instanceof Array, r = o ? [] : {}, a = o !== this.options[t] instanceof Array, h = o !== this.options[i] instanceof Array;
      a && (this.options[t] = r), h && s && (this.options[i] = r), this.options[t] = _((_a = this.options[t]) != null ? _a : r, e), (!this.options[i] || s) && (this.options[i] = _((_b = this.options[i]) != null ? _b : r, e));
    }, this.close = true, this.fill = true, this.options = {}, this.type = "circle";
  }
  get character() {
    var _a;
    return (_a = this.options[j]) != null ? _a : this.options[Q];
  }
  set character(e) {
    this.options[Q] = this.options[j] = e;
  }
  get custom() {
    return this.options;
  }
  set custom(e) {
    this.options = e;
  }
  get image() {
    var _a;
    return (_a = this.options[K]) != null ? _a : this.options[ee];
  }
  set image(e) {
    this.options[ee] = this.options[K] = e;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
  get polygon() {
    var _a;
    return (_a = this.options[te]) != null ? _a : this.options[ie];
  }
  set polygon(e) {
    this.options[ie] = this.options[te] = e;
  }
  get stroke() {
    return [];
  }
  set stroke(e) {
  }
  load(e) {
    var _a, _b, _c;
    if (!e)
      return;
    const t = (_a = e.options) != null ? _a : e.custom;
    if (t !== void 0)
      for (const i in t) {
        const s = t[i];
        s && (this.options[i] = _((_b = this.options[i]) != null ? _b : {}, s));
      }
    this.loadShape(e.character, j, Q, true), this.loadShape(e.polygon, te, ie, false), this.loadShape((_c = e.image) != null ? _c : e.images, K, ee, true), e.close !== void 0 && (this.close = e.close), e.fill !== void 0 && (this.fill = e.fill), e.type !== void 0 && (this.type = e.type);
  }
};
var ci = class extends Re {
  constructor() {
    super(), this.destroy = "none", this.speed = 5;
  }
  get size_min() {
    return this.minimumValue;
  }
  set size_min(e) {
    this.minimumValue = e;
  }
  load(e) {
    (e == null ? void 0 : e.size_min) !== void 0 && e.minimumValue === void 0 && (e.minimumValue = e.size_min), super.load(e), e && e.destroy !== void 0 && (this.destroy = e.destroy);
  }
};
var ui = class extends $ {
  constructor() {
    super(), this.animation = new ci(), this.random.minimumValue = 1, this.value = 3;
  }
  get anim() {
    return this.animation;
  }
  set anim(e) {
    this.animation = e;
  }
  load(e) {
    var _a;
    if (super.load(e), !e)
      return;
    const t = (_a = e.animation) != null ? _a : e.anim;
    t !== void 0 && (this.animation.load(t), this.value = p(this.value, this.animation.enable ? this.animation.minimumValue : void 0));
  }
};
var _e = class {
  constructor() {
    this.width = 0;
  }
  load(e) {
    e && (e.color !== void 0 && (this.color = W.create(this.color, e.color)), e.width !== void 0 && (this.width = p(e.width)), e.opacity !== void 0 && (this.opacity = p(e.opacity)));
  }
};
var fi = class extends $ {
  constructor() {
    super(), this.opacityRate = 1, this.sizeRate = 1, this.velocityRate = 1;
  }
  load(e) {
    super.load(e), e && (e.opacityRate !== void 0 && (this.opacityRate = e.opacityRate), e.sizeRate !== void 0 && (this.sizeRate = e.sizeRate), e.velocityRate !== void 0 && (this.velocityRate = e.velocityRate));
  }
};
var di = class {
  constructor(e, t) {
    this._engine = e, this._container = t, this.bounce = new Ie(), this.collisions = new Xt(), this.color = new W(), this.color.value = "#fff", this.groups = {}, this.move = new si(), this.number = new ai(), this.opacity = new oi(), this.reduceDuplicates = false, this.shadow = new hi(), this.shape = new li(), this.size = new ui(), this.stroke = new _e(), this.zIndex = new fi();
  }
  load(e) {
    var _a, _b, _c;
    var s, o, r;
    if (!e)
      return;
    if (this.bounce.load(e.bounce), this.color.load(W.create(this.color, e.color)), e.groups !== void 0)
      for (const a in e.groups) {
        const h = e.groups[a];
        h !== void 0 && (this.groups[a] = _((_a = this.groups[a]) != null ? _a : {}, h));
      }
    this.move.load(e.move), this.number.load(e.number), this.opacity.load(e.opacity), e.reduceDuplicates !== void 0 && (this.reduceDuplicates = e.reduceDuplicates), this.shape.load(e.shape), this.size.load(e.size), this.shadow.load(e.shadow), this.zIndex.load(e.zIndex);
    const t = (_b = (s = e.move) == null ? void 0 : s.collisions) != null ? _b : (o = e.move) == null ? void 0 : o.bounce;
    t !== void 0 && (this.collisions.enable = t), this.collisions.load(e.collisions), e.interactivity !== void 0 && (this.interactivity = _({}, e.interactivity));
    const i = (_c = e.stroke) != null ? _c : (r = e.shape) == null ? void 0 : r.stroke;
    if (i && (this.stroke = T(i, (a) => {
      const h = new _e();
      return h.load(a), h;
    })), this._container) {
      const a = this._engine.plugins.updaters.get(this._container);
      if (a)
        for (const l of a)
          l.loadOptions && l.loadOptions(this, e);
      const h = this._engine.plugins.interactors.get(this._container);
      if (h)
        for (const l of h)
          l.loadParticlesOptions && l.loadParticlesOptions(this, e);
    }
  }
};
function Ee(n, ...e) {
  for (const t of e)
    n.load(t);
}
function De(n, e, ...t) {
  const i = new di(n, e);
  return Ee(i, ...t), i;
}
var pi = class {
  constructor(e, t) {
    this._findDefaultTheme = (i) => {
      var _a;
      return (_a = this.themes.find((s) => s.default.value && s.default.mode === i)) != null ? _a : this.themes.find((s) => s.default.value && s.default.mode === "any");
    }, this._importPreset = (i) => {
      this.load(this._engine.plugins.getPreset(i));
    }, this._engine = e, this._container = t, this.autoPlay = true, this.background = new Ct(), this.backgroundMask = new Tt(), this.defaultThemes = {}, this.delay = 0, this.fullScreen = new Rt(), this.detectRetina = true, this.duration = 0, this.fpsLimit = 120, this.interactivity = new Te(e, t), this.manualParticles = [], this.particles = De(this._engine, this._container), this.pauseOnBlur = true, this.pauseOnOutsideViewport = true, this.responsive = [], this.smooth = false, this.style = {}, this.themes = [], this.zLayers = 100;
  }
  get backgroundMode() {
    return this.fullScreen;
  }
  set backgroundMode(e) {
    this.fullScreen.load(e);
  }
  get fps_limit() {
    return this.fpsLimit;
  }
  set fps_limit(e) {
    this.fpsLimit = e;
  }
  get retina_detect() {
    return this.detectRetina;
  }
  set retina_detect(e) {
    this.detectRetina = e;
  }
  load(e) {
    var _a, _b, _c;
    var r, a;
    if (!e)
      return;
    e.preset !== void 0 && T(e.preset, (h) => this._importPreset(h)), e.autoPlay !== void 0 && (this.autoPlay = e.autoPlay), e.delay !== void 0 && (this.delay = p(e.delay));
    const t = (_a = e.detectRetina) != null ? _a : e.retina_detect;
    t !== void 0 && (this.detectRetina = t), e.duration !== void 0 && (this.duration = p(e.duration));
    const i = (_b = e.fpsLimit) != null ? _b : e.fps_limit;
    i !== void 0 && (this.fpsLimit = i), e.pauseOnBlur !== void 0 && (this.pauseOnBlur = e.pauseOnBlur), e.pauseOnOutsideViewport !== void 0 && (this.pauseOnOutsideViewport = e.pauseOnOutsideViewport), e.zLayers !== void 0 && (this.zLayers = e.zLayers), this.background.load(e.background);
    const s = (_c = e.fullScreen) != null ? _c : e.backgroundMode;
    typeof s == "boolean" ? this.fullScreen.enable = s : this.fullScreen.load(s), this.backgroundMask.load(e.backgroundMask), this.interactivity.load(e.interactivity), e.manualParticles && (this.manualParticles = e.manualParticles.map((h) => {
      const l = new Vt();
      return l.load(h), l;
    })), this.particles.load(e.particles), this.style = _(this.style, e.style), this._engine.plugins.loadOptions(this, e), e.smooth !== void 0 && (this.smooth = e.smooth);
    const o = this._engine.plugins.interactors.get(this._container);
    if (o)
      for (const h of o)
        h.loadOptions && h.loadOptions(this, e);
    if (e.responsive !== void 0)
      for (const h of e.responsive) {
        const l = new Ht();
        l.load(h), this.responsive.push(l);
      }
    if (this.responsive.sort((h, l) => h.maxWidth - l.maxWidth), e.themes !== void 0)
      for (const h of e.themes) {
        const l = this.themes.find((c) => c.name === h.name);
        if (l)
          l.load(h);
        else {
          const c = new Wt();
          c.load(h), this.themes.push(c);
        }
      }
    this.defaultThemes.dark = (r = this._findDefaultTheme("dark")) == null ? void 0 : r.name, this.defaultThemes.light = (a = this._findDefaultTheme("light")) == null ? void 0 : a.name;
  }
  setResponsive(e, t, i) {
    this.load(i);
    const s = this.responsive.find((o) => o.mode === "screen" && screen ? o.maxWidth > screen.availWidth : o.maxWidth * t > e);
    return this.load(s == null ? void 0 : s.options), s == null ? void 0 : s.maxWidth;
  }
  setTheme(e) {
    if (e) {
      const t = this.themes.find((i) => i.name === e);
      t && this.load(t.options);
    } else {
      const t = Oe("(prefers-color-scheme: dark)"), i = t && t.matches, s = this._findDefaultTheme(i ? "dark" : "light");
      s && this.load(s.options);
    }
  }
};
var mi = class {
  constructor(e, t) {
    this.container = t, this._engine = e, this._interactors = this._engine.plugins.getInteractors(this.container, true), this._externalInteractors = [], this._particleInteractors = [];
  }
  async externalInteract(e) {
    for (const t of this._externalInteractors)
      t.isEnabled() && await t.interact(e);
  }
  handleClickMode(e) {
    for (const t of this._externalInteractors)
      t.handleClickMode && t.handleClickMode(e);
  }
  init() {
    this._externalInteractors = [], this._particleInteractors = [];
    for (const e of this._interactors) {
      switch (e.type) {
        case "external":
          this._externalInteractors.push(e);
          break;
        case "particles":
          this._particleInteractors.push(e);
          break;
      }
      e.init();
    }
  }
  async particlesInteract(e, t) {
    for (const i of this._externalInteractors)
      i.clear(e, t);
    for (const i of this._particleInteractors)
      i.isEnabled(e) && await i.interact(e, t);
  }
  async reset(e) {
    for (const t of this._externalInteractors)
      t.isEnabled() && t.reset(e);
    for (const t of this._particleInteractors)
      t.isEnabled(e) && t.reset(e);
  }
};
var we = (n) => {
  if (!rt(n.outMode, n.checkModes))
    return;
  const e = n.radius * 2;
  n.coord > n.maxCoord - e ? n.setCb(-n.radius) : n.coord < e && n.setCb(n.radius);
};
var gi = class {
  constructor(e, t, i, s, o, r) {
    this.container = i, this._calcPosition = (a, h, l, c = 0) => {
      var _a, _b, _c, _d;
      for (const [, w] of a.plugins) {
        const x = w.particlePosition !== void 0 ? w.particlePosition(h, this) : void 0;
        if (x)
          return M.create(x.x, x.y, l);
      }
      const u = a.canvas.size, d = it({
        size: u,
        position: h
      }), f = M.create(d.x, d.y, l), y = this.getRadius(), m = this.options.move.outModes, b = (w) => {
        we({
          outMode: w,
          checkModes: ["bounce", "bounce-horizontal"],
          coord: f.x,
          maxCoord: a.canvas.size.width,
          setCb: (x) => f.x += x,
          radius: y
        });
      }, k = (w) => {
        we({
          outMode: w,
          checkModes: ["bounce", "bounce-vertical"],
          coord: f.y,
          maxCoord: a.canvas.size.height,
          setCb: (x) => f.y += x,
          radius: y
        });
      };
      return b((_a = m.left) != null ? _a : m.default), b((_b = m.right) != null ? _b : m.default), k((_c = m.top) != null ? _c : m.default), k((_d = m.bottom) != null ? _d : m.default), this._checkOverlap(f, c) ? this._calcPosition(a, void 0, l, c + 1) : f;
    }, this._calculateVelocity = () => {
      const a = et(this.direction), h = a.copy(), l = this.options.move;
      if (l.direction === "inside" || l.direction === "outside")
        return h;
      const c = Math.PI / 180 * g(l.angle.value), u = Math.PI / 180 * g(l.angle.offset), d = {
        left: u - c / 2,
        right: u + c / 2
      };
      return l.straight || (h.angle += A(p(d.left, d.right))), l.random && typeof l.speed == "number" && (h.length *= S()), h;
    }, this._checkOverlap = (a, h = 0) => {
      const l = this.options.collisions, c = this.getRadius();
      if (!l.enable)
        return false;
      const u = l.overlap;
      if (u.enable)
        return false;
      const d = u.retries;
      if (d >= 0 && h > d)
        throw new Error(`${F} particle is overlapping and can't be placed`);
      return !!this.container.particles.find((f) => ae(a, f.position) < c + f.getRadius());
    }, this._getRollColor = (a) => {
      var _a;
      if (!a || !this.roll || !this.backColor && !this.roll.alter)
        return a;
      const h = this.roll.horizontal && this.roll.vertical ? 2 : 1, l = this.roll.horizontal ? Math.PI / 2 : 0;
      return Math.floor((((_a = this.roll.angle) != null ? _a : 0) + l) / (Math.PI / h)) % 2 ? this.backColor ? this.backColor : this.roll.alter ? xt(a, this.roll.alter.type, this.roll.alter.value) : a : a;
    }, this._loadShapeData = (a, h) => {
      const l = a.options[this.shape];
      if (l)
        return _({
          close: a.close,
          fill: a.fill
        }, B(l, this.id, h));
    }, this._engine = e, this.init(t, s, o, r);
  }
  destroy(e) {
    if (this.unbreakable || this.destroyed)
      return;
    this.destroyed = true, this.bubble.inRange = false, this.slow.inRange = false;
    const t = this.container, i = this.pathGenerator;
    for (const [, s] of t.plugins)
      s.particleDestroyed && s.particleDestroyed(this, e);
    for (const s of t.particles.updaters)
      s.particleDestroyed && s.particleDestroyed(this, e);
    i && i.reset(this);
  }
  draw(e) {
    const t = this.container;
    for (const [, i] of t.plugins)
      t.canvas.drawParticlePlugin(i, this, e);
    t.canvas.drawParticle(this, e);
  }
  getFillColor() {
    var _a;
    return this._getRollColor((_a = this.bubble.color) != null ? _a : ge(this.color));
  }
  getMass() {
    return this.getRadius() ** 2 * Math.PI / 2;
  }
  getPosition() {
    return {
      x: this.position.x + this.offset.x,
      y: this.position.y + this.offset.y,
      z: this.position.z
    };
  }
  getRadius() {
    var _a;
    return (_a = this.bubble.radius) != null ? _a : this.size.value;
  }
  getStrokeColor() {
    var _a;
    return this._getRollColor((_a = this.bubble.color) != null ? _a : ge(this.strokeColor));
  }
  init(e, t, i, s) {
    var _a, _b, _c, _d;
    const o = this.container, r = this._engine;
    this.id = e, this.group = s, this.fill = true, this.pathRotation = false, this.close = true, this.lastPathTime = 0, this.destroyed = false, this.unbreakable = false, this.rotation = 0, this.misplaced = false, this.retina = {
      maxDistance: {}
    }, this.outType = "normal", this.ignoresResizeRatio = true;
    const a = o.retina.pixelRatio, h = o.actualOptions, l = De(this._engine, o, h.particles), c = l.shape.type, { reduceDuplicates: u } = l;
    this.shape = B(c, this.id, u);
    const d = l.shape;
    if (i && i.shape && i.shape.type) {
      const C = i.shape.type, ce = B(C, this.id, u);
      ce && (this.shape = ce, d.load(i.shape));
    }
    this.shapeData = this._loadShapeData(d, u), l.load(i);
    const f = this.shapeData;
    f && l.load(f.particles);
    const y = new Te(r, o);
    y.load(o.actualOptions.interactivity), y.load(l.interactivity), this.interactivity = y, this.fill = (_a = f == null ? void 0 : f.fill) != null ? _a : l.shape.fill, this.close = (_b = f == null ? void 0 : f.close) != null ? _b : l.shape.close, this.options = l;
    const m = this.options.move.path;
    this.pathDelay = je(m.delay) * 1e3, m.generator && (this.pathGenerator = this._engine.plugins.getPathGenerator(m.generator), this.pathGenerator && o.addPath(m.generator, this.pathGenerator) && this.pathGenerator.init(o));
    const b = g(this.options.zIndex.value);
    o.retina.initParticle(this), this.size = ht(this.options.size, a), this.bubble = {
      inRange: false
    }, this.slow = {
      inRange: false,
      factor: 1
    }, this.position = this._calcPosition(o, t, Pe(b, 0, o.zLayers)), this.initialPosition = this.position.copy();
    const k = o.canvas.size, w = { ...this.options.move.center }, x = w.mode === "percent";
    switch (this.moveCenter = {
      x: w.x * (x ? k.width / 100 : 1),
      y: w.y * (x ? k.height / 100 : 1),
      radius: (_c = this.options.move.center.radius) != null ? _c : 0,
      mode: (_d = this.options.move.center.mode) != null ? _d : "percent"
    }, this.direction = Ke(this.options.move.direction, this.position, this.moveCenter), this.options.move.direction) {
      case "inside":
        this.outType = "inside";
        break;
      case "outside":
        this.outType = "outside";
        break;
    }
    this.initialVelocity = this._calculateVelocity(), this.velocity = this.initialVelocity.copy(), this.moveDecay = 1 - g(this.options.move.decay), this.offset = D.origin;
    const q = o.particles;
    q.needsSort = q.needsSort || q.lastZIndex < this.position.z, q.lastZIndex = this.position.z, this.zIndexFactor = this.position.z / o.zLayers, this.sides = 24;
    let z = o.drawers.get(this.shape);
    z || (z = this._engine.plugins.getShapeDrawer(this.shape), z && o.drawers.set(this.shape, z)), z && z.loadShape && z.loadShape(this);
    const le = z == null ? void 0 : z.getSidesCount;
    le && (this.sides = le(this)), this.spawning = false, this.shadowColor = L(this.options.shadow.color);
    for (const C of o.particles.updaters)
      C.init(this);
    for (const C of o.particles.movers)
      C.init && C.init(this);
    z && z.particleInit && z.particleInit(o, this);
    for (const [, C] of o.plugins)
      C.particleCreated && C.particleCreated(this);
  }
  isInsideCanvas() {
    const e = this.getRadius(), t = this.container.canvas.size, i = this.position;
    return i.x >= -e && i.y >= -e && i.y <= t.height + e && i.x <= t.width + e;
  }
  isVisible() {
    return !this.destroyed && !this.spawning && this.isInsideCanvas();
  }
  reset() {
    for (const e of this.container.particles.updaters)
      e.reset && e.reset(this);
  }
};
var yi = class {
  constructor(e, t) {
    this.position = e, this.particle = t;
  }
};
var Ae = class {
  constructor(e, t) {
    this.position = {
      x: e,
      y: t
    };
  }
};
var Le = class extends Ae {
  constructor(e, t, i) {
    super(e, t), this.radius = i;
  }
  contains(e) {
    return ae(e, this.position) <= this.radius;
  }
  intersects(e) {
    const t = e, i = e, s = this.position, o = e.position, r = { x: Math.abs(o.x - s.x), y: Math.abs(o.y - s.y) }, a = this.radius;
    if (i.radius !== void 0) {
      const h = a + i.radius, l = Math.sqrt(r.x ** 2 + r.y ** 2);
      return h > l;
    } else if (t.size !== void 0) {
      const h = t.size.width, l = t.size.height;
      return Math.pow(r.x - h, 2) + Math.pow(r.y - l, 2) <= a ** 2 || r.x <= a + h && r.y <= a + l || r.x <= h || r.y <= l;
    }
    return false;
  }
};
var U = class extends Ae {
  constructor(e, t, i, s) {
    super(e, t), this.size = {
      height: s,
      width: i
    };
  }
  contains(e) {
    const t = this.size.width, i = this.size.height, s = this.position;
    return e.x >= s.x && e.x <= s.x + t && e.y >= s.y && e.y <= s.y + i;
  }
  intersects(e) {
    e instanceof Le && e.intersects(this);
    const t = this.size.width, i = this.size.height, s = this.position, o = e.position, r = e instanceof U ? e.size : { width: 0, height: 0 }, a = r.width, h = r.height;
    return o.x < s.x + t && o.x + a > s.x && o.y < s.y + i && o.y + h > s.y;
  }
};
var N = class {
  constructor(e, t) {
    this.rectangle = e, this.capacity = t, this._subdivide = () => {
      const { x: i, y: s } = this.rectangle.position, { width: o, height: r } = this.rectangle.size, { capacity: a } = this;
      for (let h = 0; h < 4; h++)
        this._subs.push(new N(new U(i + o / 2 * (h % 2), s + r / 2 * (Math.round(h / 2) - h % 2), o / 2, r / 2), a));
      this._divided = true;
    }, this._points = [], this._divided = false, this._subs = [];
  }
  insert(e) {
    return this.rectangle.contains(e.position) ? this._points.length < this.capacity ? (this._points.push(e), true) : (this._divided || this._subdivide(), this._subs.some((t) => t.insert(e))) : false;
  }
  query(e, t, i) {
    const s = i || [];
    if (!e.intersects(this.rectangle))
      return [];
    for (const o of this._points)
      !e.contains(o.position) && ae(e.position, o.position) > o.particle.getRadius() && (!t || t(o.particle)) || s.push(o.particle);
    if (this._divided)
      for (const o of this._subs)
        o.query(e, t, s);
    return s;
  }
  queryCircle(e, t, i) {
    return this.query(new Le(e.x, e.y, t), i);
  }
  queryRectangle(e, t, i) {
    return this.query(new U(e.x, e.y, t.width, t.height), i);
  }
};
var be = 4;
var xe = (n) => new U(-n.width / 4, -n.height / 4, n.width * 3 / 2, n.height * 3 / 2);
var vi = class {
  constructor(e, t) {
    this._applyDensity = (s, o, r) => {
      var f;
      if (!((f = s.number.density) != null && f.enable))
        return;
      const a = s.number, h = this._initDensityFactor(a.density), l = a.value, c = a.limit > 0 ? a.limit : l, u = Math.min(l, c) * h + o, d = Math.min(this.count, this._array.filter((y) => y.group === r).length);
      this.limit = a.limit * h, d < u ? this.push(Math.abs(u - d), void 0, s, r) : d > u && this.removeQuantity(d - u, r);
    }, this._initDensityFactor = (s) => {
      const o = this._container;
      if (!o.canvas.element || !s.enable)
        return 1;
      const r = o.canvas.element, a = o.retina.pixelRatio;
      return r.width * r.height / (s.factor * a ** 2 * s.area);
    }, this._pushParticle = (s, o, r, a) => {
      try {
        let h = this.pool.pop();
        h ? h.init(this._nextId, s, o, r) : h = new gi(this._engine, this._nextId, this._container, s, o, r);
        let l = true;
        return a && (l = a(h)), l ? (this._array.push(h), this._zArray.push(h), this._nextId++, this._engine.dispatchEvent("particleAdded", {
          container: this._container,
          data: {
            particle: h
          }
        }), h) : void 0;
      } catch (h) {
        console.warn(`${F} adding particle: ${h}`);
        return;
      }
    }, this._engine = e, this._container = t, this._nextId = 0, this._array = [], this._zArray = [], this.pool = [], this.limit = 0, this.needsSort = false, this.lastZIndex = 0, this._interactionManager = new mi(this._engine, this._container);
    const i = this._container.canvas.size;
    this.quadTree = new N(xe(i), be), this.movers = this._engine.plugins.getMovers(this._container, true), this.updaters = this._engine.plugins.getUpdaters(this._container, true);
  }
  get count() {
    return this._array.length;
  }
  addManualParticles() {
    const e = this._container, t = e.actualOptions;
    for (const i of t.manualParticles)
      this.addParticle(i.position ? i.position.mode === "precise" ? i.position : tt({
        size: e.canvas.size,
        position: i.position
      }) : void 0, i.options);
  }
  addParticle(e, t, i, s) {
    const o = this._container, r = o.actualOptions, a = r.particles.number.limit;
    if (a > 0) {
      const h = this.count + 1 - a;
      h > 0 && this.removeQuantity(h);
    }
    return this._pushParticle(e, t, i, s);
  }
  clear() {
    this._array = [], this._zArray = [];
  }
  destroy() {
    this._array = [], this._zArray = [], this.movers = [], this.updaters = [];
  }
  async draw(e) {
    const t = this._container, i = this._container.canvas.size;
    this.quadTree = new N(xe(i), be), t.canvas.clear(), await this.update(e), this.needsSort && (this._zArray.sort((s, o) => o.position.z - s.position.z || s.id - o.id), this.lastZIndex = this._zArray[this._zArray.length - 1].position.z, this.needsSort = false);
    for (const [, s] of t.plugins)
      t.canvas.drawPlugin(s, e);
    for (const s of this._zArray)
      s.draw(e);
  }
  filter(e) {
    return this._array.filter(e);
  }
  find(e) {
    return this._array.find(e);
  }
  handleClickMode(e) {
    this._interactionManager.handleClickMode(e);
  }
  init() {
    var s;
    const e = this._container, t = e.actualOptions;
    this.lastZIndex = 0, this.needsSort = false;
    let i = false;
    this.updaters = this._engine.plugins.getUpdaters(e, true), this._interactionManager.init();
    for (const [, o] of e.plugins)
      if (o.particlesInitialization !== void 0 && (i = o.particlesInitialization()), i)
        break;
    this._interactionManager.init();
    for (const [, o] of e.pathGenerators)
      o.init(e);
    if (this.addManualParticles(), !i) {
      for (const o in t.particles.groups) {
        const r = t.particles.groups[o];
        for (let a = this.count, h = 0; h < ((s = r.number) == null ? void 0 : s.value) && a < t.particles.number.value; a++, h++)
          this.addParticle(void 0, r, o);
      }
      for (let o = this.count; o < t.particles.number.value; o++)
        this.addParticle();
    }
  }
  push(e, t, i, s) {
    this.pushing = true;
    for (let o = 0; o < e; o++)
      this.addParticle(t == null ? void 0 : t.position, i, s);
    this.pushing = false;
  }
  async redraw() {
    this.clear(), this.init(), await this.draw({ value: 0, factor: 0 });
  }
  remove(e, t, i) {
    this.removeAt(this._array.indexOf(e), void 0, t, i);
  }
  removeAt(e, t = 1, i, s) {
    if (e < 0 || e > this.count)
      return;
    let o = 0;
    for (let r = e; o < t && r < this.count; r++) {
      const a = this._array[r];
      if (!a || a.group !== i)
        continue;
      a.destroy(s), this._array.splice(r--, 1);
      const h = this._zArray.indexOf(a);
      this._zArray.splice(h, 1), this.pool.push(a), o++, this._engine.dispatchEvent("particleRemoved", {
        container: this._container,
        data: {
          particle: a
        }
      });
    }
  }
  removeQuantity(e, t) {
    this.removeAt(0, e, t);
  }
  setDensity() {
    const e = this._container.actualOptions, t = e.particles.groups;
    for (const i in t)
      this._applyDensity(t[i], 0, i);
    this._applyDensity(e.particles, e.manualParticles.length);
  }
  async update(e) {
    const t = this._container, i = /* @__PURE__ */ new Set();
    for (const [, s] of t.pathGenerators)
      s.update();
    for (const [, s] of t.plugins)
      s.update && s.update(e);
    for (const s of this._array) {
      const o = t.canvas.resizeFactor;
      o && !s.ignoresResizeRatio && (s.position.x *= o.width, s.position.y *= o.height, s.initialPosition.x *= o.width, s.initialPosition.y *= o.height), s.ignoresResizeRatio = false, await this._interactionManager.reset(s);
      for (const [, r] of this._container.plugins) {
        if (s.destroyed)
          break;
        r.particleUpdate && r.particleUpdate(s, e);
      }
      for (const r of this.movers)
        r.isEnabled(s) && r.move(s, e);
      if (s.destroyed) {
        i.add(s);
        continue;
      }
      this.quadTree.insert(new yi(s.getPosition(), s));
    }
    this._array = this._array.filter((s) => !i.has(s)), await this._interactionManager.externalInteract(e);
    for (const s of this._array) {
      for (const o of this.updaters)
        o.update(s, e);
      !s.destroyed && !s.spawning && await this._interactionManager.particlesInteract(s, e);
    }
    delete t.canvas.resizeFactor;
  }
};
var _i = class {
  constructor(e) {
    this.container = e;
  }
  init() {
    const e = this.container, t = e.actualOptions;
    this.pixelRatio = !t.detectRetina || V() ? 1 : window.devicePixelRatio, this.reduceFactor = 1;
    const i = this.pixelRatio;
    if (e.canvas.element) {
      const o = e.canvas.element;
      e.canvas.size.width = o.offsetWidth * i, e.canvas.size.height = o.offsetHeight * i;
    }
    const s = t.particles;
    this.attractDistance = g(s.move.attract.distance) * i, this.sizeAnimationSpeed = g(s.size.animation.speed) * i, this.maxSpeed = g(s.move.gravity.maxSpeed) * i;
  }
  initParticle(e) {
    const t = e.options, i = this.pixelRatio, s = t.move.distance, o = e.retina;
    o.attractDistance = g(t.move.attract.distance) * i, o.moveDrift = g(t.move.drift) * i, o.moveSpeed = g(t.move.speed) * i, o.sizeAnimationSpeed = g(t.size.animation.speed) * i;
    const r = o.maxDistance;
    r.horizontal = s.horizontal !== void 0 ? s.horizontal * i : void 0, r.vertical = s.vertical !== void 0 ? s.vertical * i : void 0, o.maxSpeed = g(t.move.gravity.maxSpeed) * i;
  }
};
function v(n) {
  return n && !n.destroyed;
}
function R(n, e, ...t) {
  const i = new pi(n, e);
  return Ee(i, ...t), i;
}
var wi = "default";
var ze = {
  generate: (n) => n.velocity,
  init: () => {
  },
  update: () => {
  },
  reset: () => {
  }
};
var bi = class {
  constructor(e, t, i) {
    this.id = t, this._intersectionManager = (s) => {
      if (!(!v(this) || !this.actualOptions.pauseOnOutsideViewport))
        for (const o of s)
          o.target === this.interactivity.element && (o.isIntersecting ? this.play : this.pause)();
    }, this._engine = e, this.fpsLimit = 120, this.smooth = false, this._delay = 0, this._duration = 0, this._lifeTime = 0, this._firstStart = true, this.started = false, this.destroyed = false, this._paused = true, this.lastFrameTime = 0, this.zLayers = 100, this.pageHidden = false, this._sourceOptions = i, this._initialSourceOptions = i, this.retina = new _i(this), this.canvas = new Mt(this), this.particles = new vi(this._engine, this), this.frameManager = new Ot(this), this.pathGenerators = /* @__PURE__ */ new Map(), this.interactivity = {
      mouse: {
        clicking: false,
        inside: false
      }
    }, this.plugins = /* @__PURE__ */ new Map(), this.drawers = /* @__PURE__ */ new Map(), this._options = R(this._engine, this), this.actualOptions = R(this._engine, this), this._eventListeners = new Pt(this), typeof IntersectionObserver < "u" && IntersectionObserver && (this._intersectionObserver = new IntersectionObserver((s) => this._intersectionManager(s))), this._engine.dispatchEvent("containerBuilt", { container: this });
  }
  get options() {
    return this._options;
  }
  get sourceOptions() {
    return this._sourceOptions;
  }
  addClickHandler(e) {
    if (!v(this))
      return;
    const t = this.interactivity.element;
    if (!t)
      return;
    const i = (u, d, f) => {
      if (!v(this))
        return;
      const y = this.retina.pixelRatio, m = {
        x: d.x * y,
        y: d.y * y
      }, b = this.particles.quadTree.queryCircle(m, f * y);
      e(u, b);
    }, s = (u) => {
      if (!v(this))
        return;
      const d = u, f = {
        x: d.offsetX || d.clientX,
        y: d.offsetY || d.clientY
      };
      i(u, f, 1);
    }, o = () => {
      v(this) && (l = true, c = false);
    }, r = () => {
      v(this) && (c = true);
    }, a = (u) => {
      if (v(this)) {
        if (l && !c) {
          const d = u;
          let f = d.touches[d.touches.length - 1];
          if (!f && (f = d.changedTouches[d.changedTouches.length - 1], !f))
            return;
          const y = this.canvas.element, m = y ? y.getBoundingClientRect() : void 0, b = {
            x: f.clientX - (m ? m.left : 0),
            y: f.clientY - (m ? m.top : 0)
          };
          i(u, b, Math.max(f.radiusX, f.radiusY));
        }
        l = false, c = false;
      }
    }, h = () => {
      v(this) && (l = false, c = false);
    };
    let l = false, c = false;
    t.addEventListener("click", s), t.addEventListener("touchstart", o), t.addEventListener("touchmove", r), t.addEventListener("touchend", a), t.addEventListener("touchcancel", h);
  }
  addLifeTime(e) {
    this._lifeTime += e;
  }
  addPath(e, t, i = false) {
    return !v(this) || !i && this.pathGenerators.has(e) ? false : (this.pathGenerators.set(e, t != null ? t : ze), true);
  }
  alive() {
    return !this._duration || this._lifeTime <= this._duration;
  }
  destroy() {
    if (!v(this))
      return;
    this.stop(), this.particles.destroy(), this.canvas.destroy();
    for (const [, i] of this.drawers)
      i.destroy && i.destroy(this);
    for (const i of this.drawers.keys())
      this.drawers.delete(i);
    this._engine.plugins.destroy(this), this.destroyed = true;
    const e = this._engine.dom(), t = e.findIndex((i) => i === this);
    t >= 0 && e.splice(t, 1), this._engine.dispatchEvent("containerDestroyed", { container: this });
  }
  draw(e) {
    if (!v(this))
      return;
    let t = e;
    this._drawAnimationFrame = nt()(async (i) => {
      t && (this.lastFrameTime = void 0, t = false), await this.frameManager.nextFrame(i);
    });
  }
  exportConfiguration() {
    return JSON.stringify(this.actualOptions, (e, t) => {
      if (!e.startsWith("_"))
        return t;
    }, 2);
  }
  exportImage(e, t, i) {
    const s = this.canvas.element;
    s && s.toBlob(e, t != null ? t : "image/png", i);
  }
  exportImg(e) {
    this.exportImage(e);
  }
  getAnimationStatus() {
    return !this._paused && !this.pageHidden && v(this);
  }
  handleClickMode(e) {
    if (v(this)) {
      this.particles.handleClickMode(e);
      for (const [, t] of this.plugins)
        t.handleClickMode && t.handleClickMode(e);
    }
  }
  async init() {
    if (!v(this))
      return;
    const e = this._engine.plugins.getSupportedShapes();
    for (const i of e) {
      const s = this._engine.plugins.getShapeDrawer(i);
      s && this.drawers.set(i, s);
    }
    this._options = R(this._engine, this, this._initialSourceOptions, this.sourceOptions), this.actualOptions = R(this._engine, this, this._options);
    const t = this._engine.plugins.getAvailablePlugins(this);
    for (const [i, s] of t)
      this.plugins.set(i, s);
    this.retina.init(), await this.canvas.init(), this.updateActualOptions(), this.canvas.initBackground(), this.canvas.resize(), this.zLayers = this.actualOptions.zLayers, this._duration = g(this.actualOptions.duration) * 1e3, this._delay = g(this.actualOptions.delay) * 1e3, this._lifeTime = 0, this.fpsLimit = this.actualOptions.fpsLimit > 0 ? this.actualOptions.fpsLimit : 120, this.smooth = this.actualOptions.smooth;
    for (const [, i] of this.drawers)
      i.init && await i.init(this);
    for (const [, i] of this.plugins)
      i.init && await i.init();
    this._engine.dispatchEvent("containerInit", { container: this }), this.particles.init(), this.particles.setDensity();
    for (const [, i] of this.plugins)
      i.particlesSetup && i.particlesSetup();
    this._engine.dispatchEvent("particlesSetup", { container: this });
  }
  async loadTheme(e) {
    v(this) && (this._currentTheme = e, await this.refresh());
  }
  pause() {
    if (v(this) && (this._drawAnimationFrame !== void 0 && (ot()(this._drawAnimationFrame), delete this._drawAnimationFrame), !this._paused)) {
      for (const [, e] of this.plugins)
        e.pause && e.pause();
      this.pageHidden || (this._paused = true), this._engine.dispatchEvent("containerPaused", { container: this });
    }
  }
  play(e) {
    if (!v(this))
      return;
    const t = this._paused || e;
    if (this._firstStart && !this.actualOptions.autoPlay) {
      this._firstStart = false;
      return;
    }
    if (this._paused && (this._paused = false), t)
      for (const [, i] of this.plugins)
        i.play && i.play();
    this._engine.dispatchEvent("containerPlay", { container: this }), this.draw(t || false);
  }
  async refresh() {
    if (v(this))
      return this.stop(), this.start();
  }
  async reset() {
    if (v(this))
      return this._initialSourceOptions = void 0, this._options = R(this._engine, this), this.actualOptions = R(this._engine, this, this._options), this.refresh();
  }
  setNoise(e, t, i) {
    v(this) && this.setPath(e, t, i);
  }
  setPath(e, t, i) {
    if (!e || !v(this))
      return;
    const s = { ...ze };
    if (typeof e == "function")
      s.generate = e, t && (s.init = t), i && (s.update = i);
    else {
      const o = s;
      s.generate = e.generate || o.generate, s.init = e.init || o.init, s.update = e.update || o.update;
    }
    this.addPath(wi, s, true);
  }
  async start() {
    !v(this) || this.started || (await this.init(), this.started = true, await new Promise((e) => {
      this._delayTimeout = setTimeout(async () => {
        this._eventListeners.addListeners(), this.interactivity.element instanceof HTMLElement && this._intersectionObserver && this._intersectionObserver.observe(this.interactivity.element);
        for (const [, t] of this.plugins)
          t.start && await t.start();
        this._engine.dispatchEvent("containerStarted", { container: this }), this.play(), e();
      }, this._delay);
    }));
  }
  stop() {
    if (!(!v(this) || !this.started)) {
      this._delayTimeout && (clearTimeout(this._delayTimeout), delete this._delayTimeout), this._firstStart = true, this.started = false, this._eventListeners.removeListeners(), this.pause(), this.particles.clear(), this.canvas.stop(), this.interactivity.element instanceof HTMLElement && this._intersectionObserver && this._intersectionObserver.unobserve(this.interactivity.element);
      for (const [, e] of this.plugins)
        e.stop && e.stop();
      for (const e of this.plugins.keys())
        this.plugins.delete(e);
      this._sourceOptions = this._options, this._engine.dispatchEvent("containerStopped", { container: this });
    }
  }
  updateActualOptions() {
    this.actualOptions.responsive = [];
    const e = this.actualOptions.setResponsive(this.canvas.size.width, this.retina.pixelRatio, this._options);
    return this.actualOptions.setTheme(this._currentTheme), this.responsiveMaxWidth === e ? false : (this.responsiveMaxWidth = e, true);
  }
};
async function xi(n, e) {
  const t = B(n, e);
  if (!t)
    return;
  const i = await fetch(t);
  if (i.ok)
    return i.json();
  console.error(`${F} ${i.status} while retrieving config file`);
}
var zi = class {
  constructor(e) {
    this._engine = e;
  }
  load(e, t, i) {
    const s = { index: i, remote: false };
    return typeof e == "string" ? s.tagId = e : s.options = e, typeof t == "number" ? s.index = t : s.options = t != null ? t : s.options, this.loadOptions(s);
  }
  async loadJSON(e, t, i) {
    let s, o;
    return typeof t == "number" || t === void 0 ? s = e : (o = e, s = t), this.loadRemoteOptions({ tagId: o, url: s, index: i, remote: true });
  }
  async loadOptions(e) {
    var _a, _b;
    const t = (_a = e.tagId) != null ? _a : `tsparticles${Math.floor(S() * 1e4)}`, { index: i, url: s, remote: o } = e, r = o ? await xi(s, i) : e.options;
    let a = (_b = e.element) != null ? _b : document.getElementById(t);
    a || (a = document.createElement("div"), a.id = t, document.body.append(a));
    const h = B(r, i), l = this._engine.dom(), c = l.findIndex((f) => f.id === t);
    if (c >= 0) {
      const f = this._engine.domItem(c);
      f && !f.destroyed && (f.destroy(), l.splice(c, 1));
    }
    let u;
    if (a.tagName.toLowerCase() === "canvas")
      u = a, u.dataset[H] = "false";
    else {
      const f = a.getElementsByTagName("canvas");
      f.length ? (u = f[0], u.dataset[H] = "false") : (u = document.createElement("canvas"), u.dataset[H] = "true", a.appendChild(u));
    }
    u.style.width || (u.style.width = "100%"), u.style.height || (u.style.height = "100%");
    const d = new bi(this._engine, t, h);
    return c >= 0 ? l.splice(c, 0, d) : l.push(d), d.canvas.loadCanvas(u), await d.start(), d;
  }
  async loadRemoteOptions(e) {
    return this.loadOptions(e);
  }
  async set(e, t, i, s) {
    const o = { index: s, remote: false };
    return typeof e == "string" ? o.tagId = e : o.element = e, t instanceof HTMLElement ? o.element = t : o.options = t, typeof i == "number" ? o.index = i : o.options = i != null ? i : o.options, this.loadOptions(o);
  }
  async setJSON(e, t, i, s) {
    let o, r, a, h;
    return e instanceof HTMLElement ? (h = e, o = t, a = i) : (r = e, h = t, o = i, a = s), this.loadRemoteOptions({ tagId: r, url: o, index: a, element: h, remote: true });
  }
};
function se(n, e, t, i = false) {
  let s = e.get(n);
  return (!s || i) && (s = [...t.values()].map((o) => o(n)), e.set(n, s)), s;
}
var Mi = class {
  constructor(e) {
    this._engine = e, this.plugins = [], this._initializers = {
      interactors: /* @__PURE__ */ new Map(),
      movers: /* @__PURE__ */ new Map(),
      updaters: /* @__PURE__ */ new Map()
    }, this.interactors = /* @__PURE__ */ new Map(), this.movers = /* @__PURE__ */ new Map(), this.updaters = /* @__PURE__ */ new Map(), this.presets = /* @__PURE__ */ new Map(), this.drawers = /* @__PURE__ */ new Map(), this.pathGenerators = /* @__PURE__ */ new Map();
  }
  addInteractor(e, t) {
    this._initializers.interactors.set(e, t);
  }
  addParticleMover(e, t) {
    this._initializers.movers.set(e, t);
  }
  addParticleUpdater(e, t) {
    this._initializers.updaters.set(e, t);
  }
  addPathGenerator(e, t) {
    this.getPathGenerator(e) || this.pathGenerators.set(e, t);
  }
  addPlugin(e) {
    this.getPlugin(e.id) || this.plugins.push(e);
  }
  addPreset(e, t, i = false) {
    (i || !this.getPreset(e)) && this.presets.set(e, t);
  }
  addShapeDrawer(e, t) {
    T(e, (i) => {
      this.getShapeDrawer(i) || this.drawers.set(i, t);
    });
  }
  destroy(e) {
    this.updaters.delete(e), this.movers.delete(e), this.interactors.delete(e);
  }
  getAvailablePlugins(e) {
    const t = /* @__PURE__ */ new Map();
    for (const i of this.plugins)
      i.needsPlugin(e.actualOptions) && t.set(i.id, i.getPlugin(e));
    return t;
  }
  getInteractors(e, t = false) {
    return se(e, this.interactors, this._initializers.interactors, t);
  }
  getMovers(e, t = false) {
    return se(e, this.movers, this._initializers.movers, t);
  }
  getPathGenerator(e) {
    return this.pathGenerators.get(e);
  }
  getPlugin(e) {
    return this.plugins.find((t) => t.id === e);
  }
  getPreset(e) {
    return this.presets.get(e);
  }
  getShapeDrawer(e) {
    return this.drawers.get(e);
  }
  getSupportedShapes() {
    return this.drawers.keys();
  }
  getUpdaters(e, t = false) {
    return se(e, this.updaters, this._initializers.updaters, t);
  }
  loadOptions(e, t) {
    for (const i of this.plugins)
      i.loadOptions(e, t);
  }
  loadParticlesOptions(e, t, ...i) {
    const s = this.updaters.get(e);
    if (s)
      for (const o of s)
        o.loadOptions && o.loadOptions(t, ...i);
  }
};
var Pi = class {
  constructor() {
    this._configs = /* @__PURE__ */ new Map(), this._domArray = [], this._eventDispatcher = new We(), this._initialized = false, this._loader = new zi(this), this.plugins = new Mi(this);
  }
  get configs() {
    const e = {};
    for (const [t, i] of this._configs)
      e[t] = i;
    return e;
  }
  get version() {
    return "2.10.1";
  }
  addConfig(e, t) {
    var _a;
    typeof e == "string" ? t && (t.name = e, this._configs.set(e, t)) : this._configs.set((_a = e.name) != null ? _a : "default", e);
  }
  addEventListener(e, t) {
    this._eventDispatcher.addEventListener(e, t);
  }
  async addInteractor(e, t) {
    this.plugins.addInteractor(e, t), await this.refresh();
  }
  async addMover(e, t) {
    this.plugins.addParticleMover(e, t), await this.refresh();
  }
  async addParticleUpdater(e, t) {
    this.plugins.addParticleUpdater(e, t), await this.refresh();
  }
  async addPathGenerator(e, t) {
    this.plugins.addPathGenerator(e, t), await this.refresh();
  }
  async addPlugin(e) {
    this.plugins.addPlugin(e), await this.refresh();
  }
  async addPreset(e, t, i = false) {
    this.plugins.addPreset(e, t, i), await this.refresh();
  }
  async addShape(e, t, i, s, o) {
    let r;
    typeof t == "function" ? r = {
      afterEffect: s,
      destroy: o,
      draw: t,
      init: i
    } : r = t, this.plugins.addShapeDrawer(e, r), await this.refresh();
  }
  dispatchEvent(e, t) {
    this._eventDispatcher.dispatchEvent(e, t);
  }
  dom() {
    return this._domArray;
  }
  domItem(e) {
    const t = this.dom(), i = t[e];
    if (!i || i.destroyed) {
      t.splice(e, 1);
      return;
    }
    return i;
  }
  init() {
    this._initialized || (this._initialized = true);
  }
  async load(e, t) {
    return this._loader.load(e, t);
  }
  async loadFromArray(e, t, i) {
    return this._loader.load(e, t, i);
  }
  async loadJSON(e, t, i) {
    return this._loader.loadJSON(e, t, i);
  }
  async refresh() {
    this.dom().forEach((e) => e.refresh());
  }
  removeEventListener(e, t) {
    this._eventDispatcher.removeEventListener(e, t);
  }
  async set(e, t, i) {
    return this._loader.set(e, t, i);
  }
  async setJSON(e, t, i, s) {
    return this._loader.setJSON(e, t, i, s);
  }
  setOnClickHandler(e) {
    const t = this.dom();
    if (!t.length)
      throw new Error(`${F} can only set click handlers after calling tsParticles.load() or tsParticles.loadJSON()`);
    for (const i of t)
      i.addClickHandler(e);
  }
};
var ki = class {
  constructor() {
    this.key = "hsl", this.stringPrefix = "hsl";
  }
  handleColor(e) {
    var _a;
    const t = e.value, i = (_a = t.hsl) != null ? _a : e.value;
    if (i.h !== void 0 && i.s !== void 0 && i.l !== void 0)
      return ne(i);
  }
  handleRangeColor(e) {
    var _a;
    const t = e.value, i = (_a = t.hsl) != null ? _a : e.value;
    if (i.h !== void 0 && i.l !== void 0)
      return ne({
        h: g(i.h),
        l: g(i.l),
        s: g(i.s)
      });
  }
  parseString(e) {
    if (!e.startsWith("hsl"))
      return;
    const t = /hsla?\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([\d.%]+)\s*)?\)/i, i = t.exec(e);
    return i ? dt({
      a: i.length > 4 ? ke(i[5]) : 1,
      h: parseInt(i[1], 10),
      l: parseInt(i[3], 10),
      s: parseInt(i[2], 10)
    }) : void 0;
  }
};
var Oi = class {
  constructor() {
    this.key = "rgb", this.stringPrefix = "rgb";
  }
  handleColor(e) {
    var _a;
    const t = e.value, i = (_a = t.rgb) != null ? _a : e.value;
    if (i.r !== void 0)
      return i;
  }
  handleRangeColor(e) {
    var _a;
    const t = e.value, i = (_a = t.rgb) != null ? _a : e.value;
    if (i.r !== void 0)
      return {
        r: g(i.r),
        g: g(i.g),
        b: g(i.b)
      };
  }
  parseString(e) {
    if (!e.startsWith(this.stringPrefix))
      return;
    const t = /rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([\d.%]+)\s*)?\)/i, i = t.exec(e);
    return i ? {
      a: i.length > 4 ? ke(i[5]) : 1,
      b: parseInt(i[3], 10),
      g: parseInt(i[2], 10),
      r: parseInt(i[1], 10)
    } : void 0;
  }
};
var Ci = new Oi();
var Si = new ki();
Ce(Ci);
Ce(Si);
var E = new Pi();
E.init();
V() || (window.tsParticles = E);
var I;
var Ti = defineComponent({
  name: "Particles",
  props: {
    id: {
      type: String,
      required: true
    },
    options: {
      type: Object
    },
    url: {
      type: String
    },
    particlesLoaded: {
      type: Function
    },
    particlesInit: {
      type: Function
    }
  },
  mounted() {
    nextTick(async () => {
      var _a;
      if (!this.id)
        throw new Error("Prop 'id' is required!");
      E.init(), this.particlesInit && await this.particlesInit(E);
      const n = (t) => {
        I = t, this.particlesLoaded && I && this.particlesLoaded(I);
      }, e = await (this.url ? E.loadJSON(this.id, this.url) : E.load(this.id, (_a = this.options) != null ? _a : {}));
      n(e);
    });
  },
  unmounted() {
    I && (I.destroy(), I = void 0);
  }
});
var Ri = (n, e) => {
  const t = n.__vccOpts || n;
  for (const [i, s] of e)
    t[i] = s;
  return t;
};
var Ii = ["id"];
function Ei(n, e, t, i, s, o) {
  return openBlock(), createElementBlock("div", { id: n.id }, null, 8, Ii);
}
var Me = Ri(Ti, [["render", Ei]]);
var Ai = (n) => {
  n.component("Particles", Me), n.component("vue-particles", Me);
};
export {
  Me as ParticlesComponent,
  Ai as default
};
//# sourceMappingURL=vue3-particles.js.map
